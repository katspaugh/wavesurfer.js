{"id":"wavesurfer.js-039","content_hash":"b00e0d24f29931285a23a3dc1a1b3a9cf95ec77ca00191b376e7220b26bac6ea","title":"Phase 4, Task 2: Extract pure peak calculation functions","description":"**Goal:** Pure peak calculation separated from stateful code.\n\n**Implementation:**\n```typescript\n// Pure functions\nexport function calculatePeaks(\n  channelData: Float32Array,\n  sampleRate: number,\n  start: number,\n  end: number,\n  numPeaks: number\n): Float32Array {\n  const length = end - start\n  const blockSize = Math.floor(length / numPeaks)\n  const peaks = new Float32Array(numPeaks)\n  \n  for (let i = 0; i \u003c numPeaks; i++) {\n    const blockStart = start + i * blockSize\n    const blockEnd = blockStart + blockSize\n    peaks[i] = findPeakInRange(channelData, blockStart, blockEnd)\n  }\n  \n  return peaks\n}\n\nexport function findPeakInRange(\n  data: Float32Array,\n  start: number,\n  end: number\n): number {\n  let peak = 0\n  for (let i = start; i \u003c end; i++) {\n    const abs = Math.abs(data[i])\n    if (abs \u003e peak) peak = abs\n  }\n  return peak\n}\n```\n\n**Dependencies:**\n- Blocks: wavesurfer.js-4dn\n\n**Success Criteria:**\n- Peak calculation fully pure\n- Easy to test\n- Can run in worker","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:47:21.108959+01:00","updated_at":"2025-11-09T21:52:22.036366+01:00","closed_at":"2025-11-09T21:52:22.036366+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-039","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:47:44.736432+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-039","depends_on_id":"wavesurfer.js-4dn","type":"blocks","created_at":"2025-11-09T16:47:44.774522+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-099","content_hash":"fd7786257b1d9161e3d9328c8e94ac6b7addb09af0332c95eb1c69cf66a09571","title":"Phase 4, Task 10: Document pure function architecture","description":"**Goal:** Document pure function architecture.\n\n**Deliverables:**\n- Architecture doc explaining pure vs impure\n- Function catalog\n- Best practices guide\n- Migration examples\n\n**Success Criteria:**\n- Complete documentation\n- Examples for common patterns\n- Contributor guide","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-09T16:47:21.525119+01:00","updated_at":"2025-11-09T16:48:24.549906+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-099","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:48:24.59016+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-0ew","content_hash":"65573699c191bd6efdc9ebf7b757b33cf62daf199a0614f49dd81e34d15626ad","title":"Phase 3, Task 6: Convert audio events to streams","description":"**Goal:** Audio element events as reactive streams.\n\n**Implementation:**\n```typescript\nprivate setupAudioStreams() {\n  const audio = this.audio\n  \n  // Play/pause stream\n  const plays = fromDOMEvent(audio, 'play')\n  const pauses = fromDOMEvent(audio, 'pause')\n  \n  plays.subscribe(() =\u003e {\n    this.playingSignal.value = true\n  })\n  \n  pauses.subscribe(() =\u003e {\n    this.playingSignal.value = false\n  })\n  \n  // Time update stream (throttled)\n  const timeUpdates = fromDOMEvent(audio, 'timeupdate')\n    .throttle(16) // ~60fps\n    .map(() =\u003e audio.currentTime)\n  \n  timeUpdates.subscribe(time =\u003e {\n    this.timeSignal.value = time\n  })\n  \n  // Loading events\n  const loadStarts = fromDOMEvent(audio, 'loadstart')\n  const loadEnds = fromDOMEvent(audio, 'canplaythrough')\n  const errors = fromDOMEvent(audio, 'error')\n  \n  loadStarts.subscribe(() =\u003e {\n    this.loadingSignal.value = true\n  })\n  \n  loadEnds.subscribe(() =\u003e {\n    this.loadingSignal.value = false\n    this.durationSignal.value = audio.duration\n  })\n  \n  errors.subscribe(e =\u003e {\n    this.errorSignal.value = e.message\n  })\n}\n```\n\n**Dependencies:**\n- Blocks: wavesurfer.js-ix6\n\n**Success Criteria:**\n- All audio events captured\n- No duplicate event firing\n- Proper cleanup on destroy","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:45:09.586341+01:00","updated_at":"2025-11-09T21:47:57.755245+01:00","closed_at":"2025-11-09T21:47:57.755245+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-0ew","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:46:18.750769+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-0ew","depends_on_id":"wavesurfer.js-ix6","type":"blocks","created_at":"2025-11-09T16:46:18.788473+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-0ib","content_hash":"66a2f759ac8050a29fd3002c8eccf689d972ea6ac107dc037e8dad7a7a75214d","title":"Phase 5: Documentation, Testing \u0026 Polish","description":"Final documentation, testing, and polish before release.\n\n## Deliverables\n- Comprehensive API documentation\n- Migration guides (users and plugin authors)\n- Updated examples\n- Video tutorials\n- \u003e90% test coverage\n- Performance validation\n- Cross-browser testing\n- Updated README and website\n- Changelog and release notes\n\n## Estimated Time\n2-3 weeks\n\n## Success Criteria\n- All documentation complete\n- All examples updated\n- All tests passing\n- Performance within targets\n- No known critical bugs\n- Ready for v8.0.0 release","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:58.47371+01:00","updated_at":"2025-11-09T14:39:14.108549+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-0ib","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T14:28:58.51376+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-0ib","depends_on_id":"wavesurfer.js-rzj","type":"blocks","created_at":"2025-11-09T14:28:58.551965+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-0lu","content_hash":"1a347085f0b6c3e8444b4ccc5c7a40b93a20b154c7bb59d654b58af431d5c0a0","title":"Phase 5, Task 5: Create migration guide for users","description":"**Goal:** Create comprehensive migration guide for users.\n\n**Guide Contents:**\n1. **Why Reactive?** - Benefits explanation\n2. **Breaking Changes** - List all API changes\n3. **Migration Steps** - Step-by-step upgrade\n4. **Before/After Examples** - Common patterns\n5. **Event System Changes** - EventEmitter → Streams\n6. **Plugin Updates** - How plugins need to adapt\n7. **Troubleshooting** - Common issues\n8. **Performance Tips** - Best practices\n\n**Example:**\n```markdown\n## Migrating from v7 to v8\n\n### Event Subscriptions\n\n**Before (v7):**\n```javascript\nwavesurfer.on('play', () =\u003e console.log('playing'))\n```\n\n**After (v8):**\n```javascript\nwavesurfer.play$.subscribe(() =\u003e console.log('playing'))\n// or with backward compat:\nwavesurfer.on('play', () =\u003e console.log('playing'))\n```\n```\n\n**Dependencies:**\n- Blocks: All phases complete\n\n**Success Criteria:**\n- Complete migration guide\n- Real-world examples\n- Video walkthrough\n- FAQ section","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-09T16:48:37.954699+01:00","updated_at":"2025-11-09T16:49:28.697816+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-0lu","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:49:28.736771+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-0m3","content_hash":"80e4b2ac80029190fff62406c6ae44e2fa5ac4295e0938adecaf8a6524bd30a8","title":"Mid-project review and course correction","description":"Mid-project review after Phase 2 \u0026 3. Validate against success metrics.\n\n## Metrics Review\n\n### Code Quality\n- LOC reduction: Target 20%, Actual ___\n- Test coverage: Target \u003e90%, Actual ___\n- Cyclomatic complexity reduction\n\n### Performance\n- Initialization time: ≤current + 10%\n- FPS during playback: ≥55fps\n- Memory usage: ≤current + 5%\n- Bundle size: ≤current + 5KB\n\n### Functionality\n- All examples working?\n- Visual parity achieved?\n- Plugins compatible?\n- No regression bugs?\n\n## Decision Gate\nPROCEED to Phase 4 if:\n- Metrics within targets\n- No critical issues\n- Team confident\n\nADJUST if:\n- Performance needs work\n- Major issues found\n- Approach needs refinement","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:29:15.797092+01:00","updated_at":"2025-11-09T14:40:56.838375+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-0m3","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T14:29:15.835978+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-0m3","depends_on_id":"wavesurfer.js-gmg","type":"blocks","created_at":"2025-11-09T14:29:15.873823+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-0m3","depends_on_id":"wavesurfer.js-9yn","type":"blocks","created_at":"2025-11-09T14:29:15.912022+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-140","content_hash":"8ac9534a37c5434e24b302d5a5f6284b6d96dc90a6a071312ca994dd7fa806dd","title":"Phase 4, Task 3: Extract pure waveform path generation","description":"**Goal:** Pure waveform path generation.\n\n**Implementation:**\n```typescript\nexport function generateWaveformPath(\n  peaks: Float32Array,\n  width: number,\n  height: number,\n  options: { normalize?: boolean; mirror?: boolean }\n): string {\n  const { normalize = true, mirror = true } = options\n  const halfHeight = height / 2\n  let path = `M 0 ${halfHeight}`\n  \n  for (let i = 0; i \u003c peaks.length; i++) {\n    const x = (i / peaks.length) * width\n    const peak = normalize ? peaks[i] : peaks[i] * halfHeight\n    const y = mirror ? halfHeight - peak : height - peak\n    path += ` L ${x} ${y}`\n  }\n  \n  if (mirror) {\n    for (let i = peaks.length - 1; i \u003e= 0; i--) {\n      const x = (i / peaks.length) * width\n      const peak = normalize ? peaks[i] : peaks[i] * halfHeight\n      const y = halfHeight + peak\n      path += ` L ${x} ${y}`\n    }\n  }\n  \n  path += ' Z'\n  return path\n}\n```\n\n**Dependencies:**\n- Blocks: wavesurfer.js-039\n\n**Success Criteria:**\n- Path generation pure\n- Easy to test\n- Snapshot tests","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:47:21.163005+01:00","updated_at":"2025-11-09T21:56:30.972047+01:00","closed_at":"2025-11-09T21:56:30.972047+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-140","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:47:57.554868+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-140","depends_on_id":"wavesurfer.js-039","type":"blocks","created_at":"2025-11-09T16:47:57.592438+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-190","content_hash":"a6374ef76758ac98198f0af6968aa0d9ec40caba7f14733969c5cc27afe5852b","title":"Review Phase 1 POC and gather feedback","description":"Review Phase 1 POC and gather team feedback before proceeding to Phase 2.\n\n## Review Checklist\n\n### Demo Reactive Primitives\n- Show signal usage\n- Demonstrate computed values\n- Show effect cleanup\n- Example with event streams\n\n### Code Review\n- Review signal implementation\n- Review state management\n- Check TypeScript types\n- Verify tests\n\n### Performance Check\n- Benchmark signal updates\n- Test with many subscribers\n- Check memory usage\n- Profile with DevTools\n\n### Team Feedback\n- Is API intuitive?\n- Any concerns about approach?\n- Suggestions for improvements?\n- Ready to proceed?\n\n## Decision Gate\nPROCEED to Phase 2 if:\n- Team approves approach\n- Performance acceptable\n- No major concerns\n- Tests passing\n\nREVISE if:\n- API needs changes\n- Performance issues\n- Team has concerns","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:29:15.628761+01:00","updated_at":"2025-11-09T20:48:13.772802+01:00","closed_at":"2025-11-09T20:48:13.772802+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-190","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T14:29:15.66944+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-190","depends_on_id":"wavesurfer.js-93k","type":"blocks","created_at":"2025-11-09T14:29:15.707714+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-1cy","content_hash":"81aeb4e6b0b30fe80ea0d5b81b50c1fd7c71a90c1327c5230b865d1fdeb7a3f8","title":"Remove virtual DOM (RenderTree/CanvasRenderer) from waveform rendering - unnecessary overhead","description":"**Problem:** The virtual DOM system (RenderTree + CanvasRenderer) adds ~500 LOC of complexity with zero performance benefit for waveform rendering.\n\n**Why Virtual DOM Doesn't Help Here:**\n\n1. **Waveforms are static**: Rendered once per audio load, only re-rendered on resize/zoom/options changes\n2. **No incremental updates**: Each render is a full redraw, diffing finds nothing to optimize\n3. **Progress/cursor use DOM**: The only frequently-updating visuals aren't on canvas\n4. **Overhead without benefit**: Tree building + diffing + cloning adds cost with no gain\n\n**Current Flow (Wasteful):**\n```typescript\n// Every waveform render does ALL of this:\n1. Build entire RenderTree from scratch (~200 nodes for bars)\n2. Diff with previous tree (O(n) algorithm)  \n3. Generate patches\n4. Apply patches by calling renderFull() anyway (negates diffing!)\n5. Clone and store tree for next diff\n```\n\n**What Actually Happens:**\n- `applyPatches()` just calls `renderFull()` (line 88 in CanvasRenderer.ts)\n- Diffing algorithm runs but provides zero optimization\n- We're doing MORE work to avoid work we weren't doing\n\n**Evidence:**\n- `useDeclarativeRendering` flag defaults to `false` (line 43)\n- Only used in experimental `renderWaveformDeclarative()` \n- Waveforms render 1-2 times per audio load, not 60fps\n- Virtual DOM benefits come from many small updates; we do few large updates\n\n**Files to Remove:**\n```bash\nrm src/renderer/RenderTree.ts\nrm src/renderer/CanvasRenderer.ts  \nrm src/renderer/__tests__/RenderTree.test.ts\nrm src/renderer/__tests__/CanvasRenderer.test.ts\nrm src/renderer/__tests__/render-batching.test.ts\n```\n\n**Files to Update:**\n\n1. **src/renderer/waveform-tree-builder.ts**\n   - Keep the path building logic (pure data transformation)\n   - Rename to `waveform-renderer.ts`\n   - Change from building trees to directly rendering to canvas:\n   \n   ```typescript\n   // OLD: Build a tree\n   export function buildWaveformRenderTree(...): RenderNode\n   \n   // NEW: Render directly to canvas\n   export function renderWaveform(\n     ctx: CanvasRenderingContext2D,\n     channelData: ChannelData,\n     options: WaveformRenderOptions\n   ): void {\n     ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n     \n     const pathData = buildWaveformPathData(channelData, width, height, vScale)\n     const path = new Path2D(pathData)\n     \n     ctx.fillStyle = waveColor\n     ctx.fill(path)\n     \n     if (progressColor \u0026\u0026 progress \u003e 0) {\n       // Render progress overlay\n     }\n   }\n   ```\n\n2. **src/renderer.ts**\n   - Remove `canvasRenderer` property\n   - Remove `useDeclarativeRendering` flag\n   - Remove `CanvasRenderer` and `RenderTree` imports\n   - Simplify `renderWaveformDeclarative()` to call direct rendering:\n   \n   ```typescript\n   private renderWaveformDeclarative(...) {\n     // Remove tree building\n     // Remove canvasRenderer.render()\n     \n     // Replace with:\n     renderWaveform(ctx, channelData, {\n       width, height, vScale,\n       waveColor, progressColor, progress,\n       shouldRenderBars, barSegments, barRadius\n     })\n   }\n   ```\n\n3. **src/renderer/cursor-tree-builder.ts**\n   - This can be removed entirely\n   - Cursor is already DOM-based in DeclarativeRenderer\n   - No canvas cursor rendering needed\n\n**Benefits:**\n- ✅ **-500 LOC**: Remove RenderTree (~250), CanvasRenderer (~200), tests (~50)\n- ✅ **Simpler**: Direct canvas API is easier to understand than virtual DOM\n- ✅ **Faster**: No tree building/diffing/cloning overhead\n- ✅ **Less memory**: No tree storage between renders\n- ✅ **Same visuals**: Identical waveform rendering\n\n**Migration Notes:**\n- Keep `buildWaveformPathData()` - it's useful pure function\n- Keep bar segment calculation - also pure data transformation  \n- Replace tree construction with direct canvas operations\n- Update tests to test canvas output, not tree structure\n\n**Success Criteria:**\n- RenderTree and CanvasRenderer completely removed\n- Waveform rendering works identically\n- All waveform tests passing (may need rewrites)\n- Performance unchanged or improved\n- Code is simpler and more direct\n\n**Estimated Effort:** 2-3 hours\n- 1 hour: Remove classes and update renderer.ts\n- 1 hour: Update waveform-tree-builder.ts to direct rendering\n- 30 min: Update/rewrite tests","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-09T21:09:07.067053+01:00","updated_at":"2025-11-09T21:13:48.123803+01:00","closed_at":"2025-11-09T21:13:48.123803+01:00","source_repo":"."}
{"id":"wavesurfer.js-1hq","content_hash":"2f03e4a98f31ef43ac04a80021df2ef4d5e4c8c270555ea836bc04fbe4d73187","title":"Refactor loadAudio to use pure functions","description":"Refactor loadAudio to use pure async function that returns data without mutating state.\n\n## Current Implementation (Imperative)\n```typescript\nprivate async loadAudio(url, blob?, channelData?, duration?) {\n  this.emit('load', url)\n  this.decodedData = null\n  this.stopAtPosition = null\n  this.abortController?.abort()\n  \n  // Lots of state mutations\n    blob = await Fetcher.fetchBlob(url, onProgress, fetchParams)\n  }\n  this.setSrc(url, blob)\n  const audioDuration = await new Promise(...)\n  this.decodedData = await Decoder.decode(arrayBuffer, sampleRate)\n  this.emit('decode', this.getDuration())\n  this.renderer.render(this.exportPeaks())\n  this.emit('ready', this.getDuration())\n}\n```\n\n## New Implementation (Pure + Shell)\n\n### Pure Function: loadAudio\nFile: src/core/audio-loader.ts\n```typescript\nexport interface AudioData {\n  buffer: AudioBuffer\n  peaks: Array\u003cFloat32Array\u003e\n  duration: number\n  url: string\n}\n\nexport interface AudioLoadOptions {\n  url: string\n  blob?: Blob\n  peaks?: Array\u003cFloat32Array\u003e\n  duration?: number\n  sampleRate: number\n  mimeType?: string\n  onProgress?: (percent: number) =\u003e void\n  signal?: AbortSignal\n}\n\nexport async function loadAudio(options: AudioLoadOptions): Promise\u003cAudioData\u003e {\n  // Pure async function - no state mutations\n  \n  let blob = options.blob\n  \n  // Fetch if needed\n    blob = await fetchWithProgress(\n      options.url,\n      options.onProgress,\n      options.signal\n    )\n  }\n  \n  // Override MIME type if provided\n  if (blob \u0026\u0026 options.mimeType) {\n    blob = new Blob([blob], { type: options.mimeType })\n  }\n  \n  // Decode audio\n  let buffer: AudioBuffer\n  if (options.peaks \u0026\u0026 options.duration) {\n    buffer = Decoder.createBuffer(options.peaks, options.duration)\n  } else if (blob) {\n    const arrayBuffer = await blob.arrayBuffer()\n    buffer = await Decoder.decode(arrayBuffer, options.sampleRate)\n  } else {\n    throw new Error('No audio data provided')\n  }\n  \n  // Extract peaks\n  const peaks = extractPeaks(buffer, options.sampleRate, 1000)\n  \n  return {\n    buffer,\n    peaks,\n    duration: buffer.duration,\n    url: options.url\n  }\n}\n\nasync function fetchWithProgress(\n  url: string,\n  onProgress?: (percent: number) =\u003e void,\n  signal?: AbortSignal\n): Promise\u003cBlob\u003e {\n  // Pure fetch with progress callback\n  const response = await fetch(url, { signal })\n  \n  const reader = response.body?.getReader()\n  const contentLength = +(response.headers.get('Content-Length') ?? 0)\n  \n  let receivedLength = 0\n  const chunks: Uint8Array[] = []\n  \n  while (reader) {\n    const { done, value } = await reader.read()\n    if (done) break\n    \n    chunks.push(value)\n    receivedLength += value.length\n    \n    if (contentLength \u0026\u0026 onProgress) {\n      onProgress((receivedLength / contentLength) * 100)\n    }\n  }\n  \n  return new Blob(chunks)\n}\n```\n\n### Shell: WaveSurfer.load()\n```typescript\nclass WaveSurfer {\n  async load(url: string, peaks?: Float32Array[], duration?: number) {\n    const abortController = new AbortController()\n    \n    try {\n      // Call pure function\n      const audioData = await loadAudio({\n        url,\n        peaks,\n        duration,\n        sampleRate: this.options.sampleRate,\n        mimeType: this.options.blobMimeType,\n        signal: abortController.signal,\n        onProgress: (percent) =\u003e this.emit('loading', percent)\n      })\n      \n      // Update state (shell responsibility)\n      this.actions.setAudioBuffer(audioData.buffer)\n      this.actions.setPeaks(audioData.peaks)\n      this.actions.setDuration(audioData.duration)\n      this.actions.setUrl(audioData.url)\n      \n      // Events fire automatically from state changes\n      \n    } catch (error) {\n      this.emit('error', error)\n    }\n  }\n}\n```\n\n## Benefits\n- loadAudio is pure (easy to test)\n- Can test without WaveSurfer instance\n- Clear separation: data loading vs state management\n- Error handling in one place\n- Can reuse loadAudio in other contexts\n\n## Testing\n- Test loadAudio with URL\n- Test loadAudio with Blob\n- Test loadAudio with peaks\n- Test progress callbacks\n- Test abort signal\n- Test MIME type override\n- Test error handling\n- Mock fetch for tests","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:25:56.078825+01:00","updated_at":"2025-11-09T14:37:46.042081+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-1hq","depends_on_id":"wavesurfer.js-rzj","type":"parent-child","created_at":"2025-11-09T14:25:56.118331+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-1hq","depends_on_id":"wavesurfer.js-l1e","type":"blocks","created_at":"2025-11-09T14:25:56.156861+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-1j7","content_hash":"3baaae150f17502d9bdd03689f7fed019bfc125d4e9a1fea0fdca8c34c4d6218","title":"Phase 2, Task 8: Implement render batching and RAF scheduling","description":"**Goal:** Batch multiple render requests and schedule them efficiently with requestAnimationFrame.\n\n**Current Problem:**\n```typescript\n// Multiple state changes trigger multiple renders\nthis.setTime(5.0)     // render()\nthis.setZoom(2.0)     // render()\nthis.setProgress(0.5) // render()\n// Result: 3 renders in one frame!\n```\n\n**Solution:**\n```typescript\nexport class RenderScheduler {\n  private pendingRender = false\n  private rafId: number | null = null\n  \n  scheduleRender(renderFn: () =\u003e void) {\n    if (this.pendingRender) return\n    \n    this.pendingRender = true\n    this.rafId = requestAnimationFrame(() =\u003e {\n      renderFn()\n      this.pendingRender = false\n      this.rafId = null\n    })\n  }\n  \n  cancelRender() {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId)\n      this.rafId = null\n      this.pendingRender = false\n    }\n  }\n  \n  // Force immediate render (for tests, screenshots)\n  flushRender(renderFn: () =\u003e void) {\n    this.cancelRender()\n    renderFn()\n  }\n}\n\n// Integrate with reactive system\nexport class Renderer {\n  private scheduler = new RenderScheduler()\n  \n  private setupReactiveRendering() {\n    // Batch all signal changes into one render\n    effect(() =\u003e {\n      // Read all signals that affect rendering\n      const time = this.timeSignal.value\n      const zoom = this.zoomSignal.value\n      const peaks = this.peaksSignal.value\n      \n      // Schedule single render\n      this.scheduler.scheduleRender(() =\u003e {\n        const tree = this.buildRenderTree()\n        this.canvasRenderer.render(tree, this.ctx)\n      })\n    })\n  }\n}\n```\n\n**Advanced Features:**\n```typescript\n// Priority-based rendering\nclass RenderScheduler {\n  scheduleRender(renderFn: () =\u003e void, priority: 'high' | 'normal' | 'low' = 'normal') {\n    if (priority === 'high') {\n      // Immediate render for critical updates (cursor during playback)\n      this.flushRender(renderFn)\n    } else {\n      // Batched render for normal updates\n      this.scheduleRender(renderFn)\n    }\n  }\n}\n```\n\n**Dependencies:**\n- Blocks: wavesurfer.js-uas (needs rendering system)\n\n**Success Criteria:**\n- Multiple state changes result in single render\n- Smooth 60fps animations\n- No duplicate renders in same frame\n- Tests can force synchronous rendering\n- Priority rendering works for critical updates","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:41:38.734968+01:00","updated_at":"2025-11-09T19:46:39.18139+01:00","closed_at":"2025-11-09T19:46:39.18139+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-1j7","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:41:54.547484+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-1j7","depends_on_id":"wavesurfer.js-uas","type":"blocks","created_at":"2025-11-09T16:41:54.585233+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-26l","content_hash":"88ba11dd0b7a72caa659efb2268d9274f480f5756e4dbe3411be9d4c5e7c3b87","title":"Phase 5: Refactor Plugins to reactive architecture","description":"Transform the plugin system from imperative event handlers to reactive subscriptions.\n\n**Current State:**\n- Plugins subscribe to events imperatively\n- Manual state synchronization in plugins\n- Tight coupling to WaveSurfer internals\n\n**Target State:**\n- Plugins use reactive subscriptions\n- Declarative plugin lifecycle\n- Standardized plugin interface with store access\n- Automatic cleanup on plugin destruction\n\n**Implementation Steps:**\n\n1. Create reactive plugin base class:\n```typescript\nabstract class ReactivePlugin {\n  protected subscriptions: (() =\u003e void)[] = []\n  protected store: WaveSurferStore\n  \n  constructor(protected wavesurfer: WaveSurfer) {\n    this.store = wavesurfer.getStore()\n  }\n  \n  // Override in subclasses\n  abstract onInit(): void\n  \n  // Helper to subscribe with auto-cleanup\n  protected subscribe\u003cK extends keyof WaveSurferState\u003e(\n    keys: K[],\n    callback: (state: Pick\u003cWaveSurferState, K\u003e) =\u003e void\n  ) {\n    const unsubscribe = this.store.subscribe(keys, callback)\n    this.subscriptions.push(unsubscribe)\n    return unsubscribe\n  }\n  \n  destroy() {\n    this.subscriptions.forEach(unsub =\u003e unsub())\n    this.subscriptions = []\n  }\n}\n```\n\n2. Refactor existing plugins (example - Regions):\n```typescript\nclass RegionsPlugin extends ReactivePlugin {\n  private regions: Region[] = []\n  \n  onInit() {\n    // Subscribe to relevant state\n    this.subscribe(\n      ['currentTime', 'duration'],\n      ({ currentTime, duration }) =\u003e {\n        this.updateRegionPositions(currentTime, duration)\n      }\n    )\n    \n    this.subscribe(\n      ['zoom', 'width'],\n      ({ zoom, width }) =\u003e {\n        this.updateRegionScaling(zoom, width)\n      }\n    )\n  }\n  \n  addRegion(options: RegionOptions) {\n    const region = new Region(options, this.store)\n    this.regions.push(region)\n    // Region automatically subscribes to store\n    return region\n  }\n}\n```\n\n3. Update plugin registration:\n```typescript\nclass WaveSurfer {\n  registerPlugin\u003cT extends ReactivePlugin\u003e(\n    PluginClass: new (ws: WaveSurfer) =\u003e T\n  ): T {\n    const plugin = new PluginClass(this)\n    plugin.onInit()\n    this.plugins.push(plugin)\n    return plugin\n  }\n}\n```\n\n**Plugins to Refactor:**\n- Regions plugin\n- Timeline plugin\n- Minimap plugin\n- Spectrogram plugin\n- Any custom plugins\n\n**Success Criteria:**\n- All plugins extend ReactivePlugin\n- No direct event listeners in plugins\n- Automatic subscription cleanup\n- Plugin state derived from store\n- Tests pass for all plugins\n\n**Dependencies:**\n- Reactive store implementation\n- Core WaveSurfer refactored\n- Renderer refactored\n\n**Estimated Effort:** 2 weeks","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T16:23:30.700637+01:00","updated_at":"2025-11-09T16:23:30.700637+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-26l","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:24:14.964283+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-26l","depends_on_id":"wavesurfer.js-cg4","type":"blocks","created_at":"2025-11-09T16:24:43.375625+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-26l","depends_on_id":"wavesurfer.js-jwq","type":"blocks","created_at":"2025-11-09T16:24:43.414852+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-2nt","content_hash":"f024e1eaa75315fa90d37a7d8fb2e2bdee136eb1c6471faf403532d84e2b9761","title":"Phase 2, Task 9: Add layer compositing system","description":"**Goal:** Implement a layer system for efficient partial canvas updates of waveform and spectrogram rendering.\n\n**Rendering Architecture Clarification:**\n- **Canvas layers:** Only waveform and spectrogram\n- **DOM elements:** Everything else (regions, cursor, timeline, hover, etc.)\n- This task focuses solely on canvas-rendered elements\n\n**Motivation:**\n- Waveform rarely changes (only on zoom, decode, or resize)\n- Spectrogram rarely changes (only on decode, color map, or resize)\n- Need efficient updates without full redraws\n- Both can be on separate canvas layers for independent updates\n\n**Implementation:**\n```typescript\nexport enum CanvasLayer {\n  WAVEFORM = 0,    // Waveform/bars (changes on zoom, decode, resize)\n  SPECTROGRAM = 1  // Spectrogram (changes on decode, color change, resize)\n}\n\nexport class LayeredCanvasRenderer {\n  private canvases: Map\u003cCanvasLayer, HTMLCanvasElement\u003e = new Map()\n  private trees: Map\u003cCanvasLayer, RenderTree\u003e = new Map()\n  \n  constructor(private container: HTMLElement) {\n    // Create canvas for each layer\n    Object.values(CanvasLayer).forEach(layer =\u003e {\n      if (typeof layer === 'number') {\n        const canvas = document.createElement('canvas')\n        canvas.style.position = 'absolute'\n        canvas.style.zIndex = String(layer)\n        this.container.appendChild(canvas)\n        this.canvases.set(layer, canvas)\n      }\n    })\n  }\n  \n  renderLayer(layer: CanvasLayer, tree: RenderTree) {\n    const canvas = this.canvases.get(layer)!\n    const ctx = canvas.getContext('2d')!\n    \n    // Only redraw if tree changed\n    const prevTree = this.trees.get(layer)\n    if (prevTree \u0026\u0026 prevTree.equals(tree)) return\n    \n    // Clear and render\n    ctx.clearRect(0, 0, canvas.width, canvas.height)\n    this.renderer.render(tree, ctx)\n    this.trees.set(layer, tree)\n  }\n  \n  // Convenient methods\n  updateWaveform(peaks: number[], zoom: number) {\n    this.renderLayer(CanvasLayer.WAVEFORM, this.buildWaveformTree(peaks, zoom))\n  }\n  \n  updateSpectrogram(fftData: number[][]) {\n    this.renderLayer(CanvasLayer.SPECTROGRAM, this.buildSpectrogramTree(fftData))\n  }\n}\n```\n\n**Usage:**\n```typescript\n// When zoom changes, only waveform layer redraws\neffect(() =\u003e {\n  const zoom = this.zoomSignal.value\n  const peaks = this.peaksSignal.value\n  this.layeredRenderer.updateWaveform(peaks, zoom)\n})\n\n// When spectrogram data changes, only spectrogram layer redraws\neffect(() =\u003e {\n  const fftData = this.fftDataSignal.value\n  this.layeredRenderer.updateSpectrogram(fftData) // Doesn't affect waveform\n})\n```\n\n**DOM Element Rendering:**\n- Cursor: DOM element (`\u003cdiv class=\"cursor\"\u003e`) - already implemented\n- Regions: DOM elements - handled by Regions plugin (Task 5)\n- Timeline: DOM elements - separate plugin\n- Hover: DOM elements - separate plugin\n- These are NOT part of this task\n\n**Performance Benefits:**\n- Spectrogram updates don't trigger waveform redraw\n- Waveform zooming doesn't affect spectrogram\n- Both layers cache independently\n- ~50-70% reduction in canvas operations\n\n**Dependencies:**\n- Blocks: wavesurfer.js-uas (needs RenderTree)\n- Blocks: wavesurfer.js-1j7 (needs render scheduling)\n\n**Success Criteria:**\n- 2 independent canvas layers (waveform + spectrogram)\n- Partial updates work correctly\n- Layers composite correctly (z-order)\n- Performance targets met\n- Tests verify layer isolation\n- Does NOT handle DOM elements (cursor, regions, etc.)","notes":"CLOSED: Task based on incorrect assumption. Spectrogram is a separate plugin with its own container/canvas (see src/plugins/spectrogram.ts), never overlaid on waveform. No need for multi-layer canvas system. DOM-based rendering for cursor/regions (Tasks 4-7) already handles interactive elements efficiently. Waveform uses single canvas, spectrogram uses its own separate canvas in a different container.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-09T16:42:00.174131+01:00","updated_at":"2025-11-09T20:47:02.787534+01:00","closed_at":"2025-11-09T20:47:02.178824+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-2nt","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:42:18.1464+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-2nt","depends_on_id":"wavesurfer.js-uas","type":"blocks","created_at":"2025-11-09T16:42:18.185066+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-2nt","depends_on_id":"wavesurfer.js-1j7","type":"blocks","created_at":"2025-11-09T16:42:18.226071+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-2pc","content_hash":"ce098e1304d5ed4d71bd1453f15349f59347cc3576074c6086db60f0bf476739","title":"Cross-browser compatibility testing","description":"Test reactive implementation across all major browsers.\n\n## Browsers to Test\n- Chrome (latest, latest-1)\n- Firefox (latest, latest-1)\n- Safari (latest, latest-1)\n- Edge (latest)\n- Mobile Safari (iOS latest)\n- Mobile Chrome (Android latest)\n\n## Test Areas\n- Reactive primitives\n- Shadow DOM rendering\n- Media element behavior\n- Performance\n- Memory usage\n- Touch events\n\n## Tools\n- BrowserStack\n- Cypress\n- Manual testing\n\n## Success Criteria\n- All tests pass\n- No console errors\n- Performance acceptable\n- UI works correctly","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:59.390436+01:00","updated_at":"2025-11-09T14:39:14.442261+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-2pc","depends_on_id":"wavesurfer.js-0ib","type":"parent-child","created_at":"2025-11-09T14:28:59.431239+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-2w1","content_hash":"e1fe209d63f5786594746d4eeaf7bd6f320f70ff334b4ebf966d35db7420fae5","title":"Performance benchmarking and optimization","description":"Benchmark reactive implementation vs old version. Optimize if needed.\n\n## Metrics to Measure\n- Initialization time\n- First render time\n- Playback FPS\n- Memory usage during playback\n- Memory after destroy\n- Bundle size\n\n## Benchmarks\n- Load 10s audio file\n- Load 5min audio file\n- Multi-channel rendering\n- 100 regions\n- Rapid zoom changes\n- 1000 play/pause cycles\n\n## Targets\n- Initialization: ≤current + 10%\n- FPS: ≥55fps (current ~60fps)\n- Memory: ≤current + 5%\n- Bundle: ≤current + 5KB\n\n## Optimization Strategies\n- Batch state updates\n- Memoize computed values\n- Debounce expensive operations\n- Lazy initialization\n- Canvas pooling\n\n## Tools\n- Chrome DevTools Performance\n- Memory profiler\n- bundlephobia\n- Custom benchmarks","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:59.202551+01:00","updated_at":"2025-11-09T14:39:14.357236+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-2w1","depends_on_id":"wavesurfer.js-0ib","type":"parent-child","created_at":"2025-11-09T14:28:59.241728+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-32u","content_hash":"bba727a6f9f0088d2eef81e92bf743d3d500f84c519412f31148fa3cbc8009b0","title":"Implement event stream utilities","description":"Convert DOM events to reactive streams for composable event handling.\n\n## Implementation\nFile: src/reactive/event-streams.ts\n\n### fromEvent\u003cK\u003e(element, eventName): Signal\u003cEvent\u003e\n- Converts DOM events to reactive signal\n- Automatically adds/removes event listeners\n- Stores cleanup function for later removal\n\n### map\u003cT, U\u003e(source, mapper): Signal\u003cU\u003e\n- Transforms stream values\n- Pure function transformation\n- Creates new signal with mapped values\n\n### filter\u003cT\u003e(source, predicate): Signal\u003cT | null\u003e\n- Filters stream values by predicate\n- Only emits values that pass test\n- Returns null for filtered values\n\n### debounce\u003cT\u003e(source, delay): Signal\u003cT\u003e\n- Debounces stream updates\n- Useful for drag events, resize, etc.\n- Automatically clears timeout on cleanup\n\n### throttle\u003cT\u003e(source, delay): Signal\u003cT\u003e\n- Throttles stream updates\n- Limits update frequency\n- Different from debounce (emits immediately, then waits)\n\n## Testing\n- Test fromEvent converts DOM events\n- Test map transforms values correctly\n- Test filter only passes matching values\n- Test debounce delays updates\n- Test throttle limits frequency\n- Test cleanup removes listeners\n- Test stream composition (map + filter + debounce)\n\n## Example Usage\n```typescript\nconst clicks = fromEvent(button, 'click')\nconst positions = map(clicks, e =\u003e e.clientX)\nconst filtered = filter(positions, x =\u003e x \u003e 100)\nconst debounced = debounce(filtered, 200)\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:04.924245+01:00","updated_at":"2025-11-09T14:49:14.269836+01:00","closed_at":"2025-11-09T14:49:14.269836+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-32u","depends_on_id":"wavesurfer.js-93k","type":"parent-child","created_at":"2025-11-09T14:23:04.962479+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-32u","depends_on_id":"wavesurfer.js-61x","type":"blocks","created_at":"2025-11-09T14:23:04.999588+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-37m","content_hash":"d95025ea318d637e6bd972d8713b84be22ecac19c8efa4b7af4844cc3082388d","title":"Create cursor and progress components","description":"Create reusable cursor and progress bar components using component system.\n\n## CursorComponent\nFile: src/components/cursor.ts\n\n```typescript\nexport const CursorComponent = createComponent\u003c{\n  position: number  // 0-1\n  color: string\n  width: number\n  height: string\n}\u003e(\n  (props) =\u003e {\n    const cursor = document.createElement('div')\n    cursor.className = 'cursor'\n    cursor.style.position = 'absolute'\n    cursor.style.zIndex = '5'\n    cursor.style.top = '0'\n    cursor.style.left = `${props.position * 100}%`\n    cursor.style.height = props.height\n    cursor.style.width = `${props.width}px`\n    cursor.style.backgroundColor = props.color\n    cursor.style.borderRadius = '2px'\n    cursor.style.pointerEvents = 'none'\n    return cursor\n  },\n  (element, props) =\u003e {\n    if (props.position !== undefined)\n      element.style.left = `${props.position * 100}%`\n    if (props.color !== undefined)\n      element.style.backgroundColor = props.color\n    if (props.width !== undefined)\n      element.style.width = `${props.width}px`\n    if (props.height !== undefined)\n      element.style.height = props.height\n  }\n)\n```\n\n## ProgressComponent\nFile: src/components/progress.ts\n\n```typescript\nexport const ProgressComponent = createComponent\u003c{\n  progress: number  // 0-1\n  color: string\n  height: string\n}\u003e(\n  (props) =\u003e {\n    const wrapper = document.createElement('div')\n    wrapper.className = 'progress'\n    wrapper.style.position = 'absolute'\n    wrapper.style.zIndex = '2'\n    wrapper.style.top = '0'\n    wrapper.style.left = '0'\n    wrapper.style.width = `${props.progress * 100}%`\n    wrapper.style.height = props.height\n    wrapper.style.overflow = 'hidden'\n    wrapper.style.pointerEvents = 'none'\n    \n    const inner = document.createElement('div')\n    inner.style.position = 'relative'\n    wrapper.appendChild(inner)\n    \n    return wrapper\n  },\n  (element, props) =\u003e {\n    if (props.progress !== undefined)\n      element.style.width = `${props.progress * 100}%`\n    if (props.color !== undefined)\n      element.style.backgroundColor = props.color\n    if (props.height !== undefined)\n      element.style.height = props.height\n  }\n)\n```\n\n## Usage in DeclarativeRenderer\n```typescript\nclass DeclarativeRenderer {\n  private cursor: Component\u003cCursorProps\u003e\n  private progress: Component\u003cProgressProps\u003e\n  \n  constructor() {\n    this.cursor = CursorComponent.render({\n      position: 0,\n      color: options.cursorColor,\n      width: options.cursorWidth,\n      height: '100%'\n    })\n    \n    this.progress = ProgressComponent.render({\n      progress: 0,\n      color: options.progressColor,\n      height: '100%'\n    })\n    \n    // Reactive updates\n    effect(\n      () =\u003e this.cursor.update?.({ position: state.progressPercent.value }),\n      [state.progressPercent]\n    )\n    \n    effect(\n      () =\u003e this.progress.update?.({ progress: state.progressPercent.value }),\n      [state.progressPercent]\n    )\n  }\n}\n```\n\n## Testing\n- Test cursor renders at correct position\n- Test cursor updates position\n- Test cursor respects color/width options\n- Test progress bar renders at correct width\n- Test progress bar updates width\n- Test components cleanup properly","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:45.33718+01:00","updated_at":"2025-11-09T15:27:23.54088+01:00","closed_at":"2025-11-09T15:27:23.54088+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-37m","depends_on_id":"wavesurfer.js-gmg","type":"parent-child","created_at":"2025-11-09T14:23:45.375553+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-37m","depends_on_id":"wavesurfer.js-3mr","type":"blocks","created_at":"2025-11-09T14:23:45.414907+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-389","content_hash":"3b113be979bf17edf4199f6b1a0c2420972833ef5dee9455311a4f0e86ccea96","title":"Update remaining official plugins","description":"Migrate remaining plugins (Zoom, Hover, Envelope, Record, Spectrogram) to reactive patterns where beneficial.","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:25:56.794693+01:00","updated_at":"2025-11-09T14:39:14.024641+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-389","depends_on_id":"wavesurfer.js-rzj","type":"parent-child","created_at":"2025-11-09T14:25:56.833786+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-389","depends_on_id":"wavesurfer.js-3zw","type":"blocks","created_at":"2025-11-09T14:25:56.874066+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-389","depends_on_id":"wavesurfer.js-8ua","type":"blocks","created_at":"2025-11-09T14:25:56.914165+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-389","depends_on_id":"wavesurfer.js-tzi","type":"blocks","created_at":"2025-11-09T14:25:56.954187+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-3ac","content_hash":"46bced5eef2e0cd2ce1fed3873dba19ad196c0722135e480466d62adccc2b120","title":"Memory leak testing and fixes","description":"Test for memory leaks using automated tools and fix any found.\n\n## Testing Strategy\n1. Automated leak detection\n2. Manual profiling\n3. Stress testing\n4. Long-running tests\n\n## Test Scenarios\n- Create/destroy 100 times\n- Load different audio files\n- Add/remove 100 regions\n- Register/unregister plugins\n- Long playback (1 hour)\n\n## Tools\n- Chrome DevTools Memory\n- memlab (Meta's tool)\n- Manual heap snapshots\n- CI integration\n\n## Success Criteria\n- No detached DOM nodes\n- Event listeners cleaned up\n- RAF canceled properly\n- \u003c 1MB growth after 100 cycles","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:59.296038+01:00","updated_at":"2025-11-09T14:39:14.399984+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-3ac","depends_on_id":"wavesurfer.js-0ib","type":"parent-child","created_at":"2025-11-09T14:28:59.336272+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-3mr","content_hash":"77e830ce40857c54c532e423b566421803d336a6b8033bd93b88dd9df91b59aa","title":"Create declarative component system","description":"Create declarative component factory for reusable UI components.\n\n## Implementation\nFile: src/components/component.ts\n\n### Component\u003cP\u003e Interface\n```typescript\ninterface Component\u003cP extends ComponentProps\u003e {\n  render(props: P): HTMLElement\n  update?(props: Partial\u003cP\u003e): void\n  destroy?(): void\n}\n```\n\n### createComponent\u003cP\u003e(render, update?)\nFactory function that returns Component\u003cP\u003e\n- render: Creates initial DOM element\n- update: Updates existing element (optional)\n- destroy: Cleanup (optional)\n\n### Component Lifecycle\n1. Component created with createComponent()\n2. render(props) called → returns HTMLElement\n3. update(newProps) can be called multiple times\n4. destroy() called on cleanup\n\n## Example Components\n\n### CursorComponent\n```typescript\nconst CursorComponent = createComponent\u003c{\n  position: number\n  color: string\n  width: number\n}\u003e(\n  (props) =\u003e {\n    const el = document.createElement('div')\n    el.className = 'cursor'\n    el.style.left = `${props.position * 100}%`\n    el.style.backgroundColor = props.color\n    el.style.width = `${props.width}px`\n    return el\n  },\n  (el, props) =\u003e {\n    if (props.position !== undefined)\n      el.style.left = `${props.position * 100}%`\n    if (props.color !== undefined)\n      el.style.backgroundColor = props.color\n    if (props.width !== undefined)\n      el.style.width = `${props.width}px`\n  }\n)\n```\n\n## Testing\n- Test component creation\n- Test render returns element\n- Test update modifies element\n- Test destroy cleanup\n- Test TypeScript types\n- Test partial updates\n- Test missing update function\n\n## Integration with Reactive\nComponents work with effects:\n```typescript\nconst cursor = CursorComponent.render({ position: 0, color: '#fff', width: 2 })\neffect(\n  () =\u003e cursor.update?.({ position: state.progressPercent.value }),\n  [state.progressPercent]\n)\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:44.724431+01:00","updated_at":"2025-11-09T15:19:54.216156+01:00","closed_at":"2025-11-09T15:19:54.216156+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-3mr","depends_on_id":"wavesurfer.js-gmg","type":"parent-child","created_at":"2025-11-09T14:23:44.762928+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-3zw","content_hash":"ae3bec1b01eb4cbf7757dcffb3d05ba0e7812aac25df854e7d645fbf554b0f87","title":"Migrate Regions plugin to reactive pattern","description":"Migrate Regions plugin to use reactive state. Model for other plugin migrations.\n\n## Current Issues in Regions Plugin\n- Manual tracking of active regions\n- Imperative region enter/exit detection\n- Manual subscriptions to wavesurfer events\n- Manual rendering\n\n## New Reactive Implementation\n\n### Reactive Region State\n```typescript\nclass RegionsPlugin extends BasePlugin {\n  private regions = signal\u003cRegion[]\u003e([])\n  \n  // Automatically computed active regions\n  private activeRegions = computed(\n    () =\u003e {\n      const time = this.wavesurfer.state.currentTime.value\n      return this.regions.value.filter(\n        region =\u003e time \u003e= region.start \u0026\u0026 time \u003c= region.end\n      )\n    },\n    [this.wavesurfer.state.currentTime, this.regions]\n  )\n  \n  _init(wavesurfer: WaveSurfer) {\n    super._init(wavesurfer)\n    this.setupReactiveRegions()\n  }\n  \n  private setupReactiveRegions() {\n    // Automatically detect enter/exit\n    let previousActive = new Set\u003cRegion\u003e()\n    \n    effect(\n      () =\u003e {\n        const currentActive = new Set(this.activeRegions.value)\n        \n        // Enter events\n        currentActive.forEach(region =\u003e {\n            this.emit('region-in', region)\n          }\n        })\n        \n        // Exit events\n        previousActive.forEach(region =\u003e {\n            this.emit('region-out', region)\n          }\n        })\n        \n        previousActive = currentActive\n      },\n      [this.activeRegions]\n    )\n    \n    // Auto re-render when regions change\n    effect(\n      () =\u003e this.renderAllRegions(this.regions.value),\n      [this.regions]\n    )\n  }\n  \n  addRegion(params: RegionParams): Region {\n    const region = new SingleRegion(\n      params,\n      this.wavesurfer.state.duration.value\n    )\n    \n    // Update signal (triggers auto re-render)\n    this.regions.update(regions =\u003e [...regions, region])\n    \n    this.emit('region-created', region)\n    return region\n  }\n  \n  removeRegion(region: Region) {\n    this.regions.update(regions =\u003e regions.filter(r =\u003e r !== region))\n    this.emit('region-removed', region)\n  }\n}\n```\n\n## Benefits\n- Active region detection is automatic\n- No manual subscriptions\n- Declarative state management\n- Easier to test\n- Better performance (computed caches)\n\n## Testing\n- Test active region detection\n- Test region enter/exit events\n- Test adding/removing regions\n- Test region updates trigger re-render\n- Test with multiple regions\n- Test edge cases (overlapping regions)","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:25:56.385457+01:00","updated_at":"2025-11-09T14:39:13.9066+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-3zw","depends_on_id":"wavesurfer.js-rzj","type":"parent-child","created_at":"2025-11-09T14:25:56.426294+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-3zw","depends_on_id":"wavesurfer.js-jwq","type":"blocks","created_at":"2025-11-09T14:25:56.465247+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-4dn","content_hash":"c86ae5d85fe38bf546efc7a769dbff94eb7d61d4e1f3b14b6d4f6ecef7ca90ac","title":"Phase 4, Task 1: Extract pure audio decoding functions","description":"**Goal:** Separate audio decoding logic into pure, testable functions.\n\n**Current Code:**\n```typescript\nclass Decoder {\n  async decodeAudio(arrayBuffer: ArrayBuffer): Promise\u003cAudioBuffer\u003e {\n    const audioContext = new AudioContext()\n    return audioContext.decodeAudioData(arrayBuffer)\n  }\n}\n```\n\n**New Code:**\n```typescript\n// Pure function - takes input, returns output\nexport function extractChannelData(audioBuffer: AudioBuffer): Float32Array[] {\n  const channels: Float32Array[] = []\n  for (let i = 0; i \u003c audioBuffer.numberOfChannels; i++) {\n    channels.push(audioBuffer.getChannelData(i))\n  }\n  return channels\n}\n\nexport function normalizeChannelData(data: Float32Array): Float32Array {\n  const max = Math.max(...Array.from(data).map(Math.abs))\n  if (max === 0) return data\n  return data.map(v =\u003e v / max) as Float32Array\n}\n\nexport function mergeChannels(channels: Float32Array[]): Float32Array {\n  if (channels.length === 1) return channels[0]\n  \n  const length = channels[0].length\n  const merged = new Float32Array(length)\n  \n  for (let i = 0; i \u003c length; i++) {\n    let sum = 0\n    for (const channel of channels) {\n      sum += channel[i]\n    }\n    merged[i] = sum / channels.length\n  }\n  \n  return merged\n}\n\n// Side-effecting wrapper\nclass Decoder {\n  async decodeAudio(arrayBuffer: ArrayBuffer): Promise\u003cFloat32Array[]\u003e {\n    const audioContext = new AudioContext()\n    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer)\n    return extractChannelData(audioBuffer) // Pure function\n  }\n}\n```\n\n**Benefits:**\n- Easy to test without AudioContext\n- Can run in Web Workers\n- Composable transformations\n- Memoizable\n\n**Dependencies:**\n- Blocks: None (independent)\n\n**Success Criteria:**\n- All audio processing functions pure\n- Unit tests without mocking\n- Works in Web Workers\n- Performance maintained","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:47:21.054825+01:00","updated_at":"2025-11-09T21:50:12.642247+01:00","closed_at":"2025-11-09T21:50:12.642247+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-4dn","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:47:34.717121+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-4xj","content_hash":"68882ba80cc8b142b893e73e99930b1ecc47fccedefd07527aadefb11e7cdb4d","title":"Phase 3, Task 8: Implement region interaction streams","description":"**Goal:** Region interactions (click, drag, resize) as streams.\n\n**Implementation:**\n```typescript\n// In RegionsPlugin\nprivate setupRegionInteractionStreams(region: Region) {\n  const element = region.element\n  \n  // Click stream\n  const clicks = fromDOMEvent(element, 'click')\n  clicks.subscribe(e =\u003e {\n    this.activeRegionSignal.value = region\n    this.emit('region-clicked', region)\n  })\n  \n  // Drag entire region\n  const regionDrags = createDragStream(element)\n  \n  regionDrags.subscribe(drag =\u003e {\n    if (drag.type === 'move') {\n      const deltaTime = this.pixelToTime(drag.deltaX)\n      region.start += deltaTime\n      region.end += deltaTime\n      this.regionsSignal.value = [...this.regions] // Trigger update\n    }\n  })\n  \n  // Resize handles\n  const leftHandle = region.leftHandleElement\n  const rightHandle = region.rightHandleElement\n  \n  const leftDrags = createDragStream(leftHandle)\n  leftDrags.subscribe(drag =\u003e {\n    if (drag.type === 'move') {\n      region.start = this.pixelToTime(drag.x)\n      this.regionsSignal.value = [...this.regions]\n    }\n  })\n  \n  const rightDrags = createDragStream(rightHandle)\n  rightDrags.subscribe(drag =\u003e {\n    if (drag.type === 'move') {\n      region.end = this.pixelToTime(drag.x)\n      this.regionsSignal.value = [...this.regions]\n    }\n  })\n  \n  // Double-click to play region\n  const dblclicks = clicks\n    .timeWindow(300) // 300ms window\n    .filter(events =\u003e events.length === 2)\n  \n  dblclicks.subscribe(() =\u003e {\n    this.wavesurfer.play(region.start, region.end)\n  })\n}\n```\n\n**Dependencies:**\n- Blocks: wavesurfer.js-ix6\n- Blocks: wavesurfer.js-919 (drag streams)\n\n**Success Criteria:**\n- All region interactions work\n- Smooth drag/resize\n- Handle constraints (min/max size)\n- Multi-region selection support","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T16:45:30.68696+01:00","updated_at":"2025-11-09T16:46:40.19616+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-4xj","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:46:40.237416+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-4xj","depends_on_id":"wavesurfer.js-ix6","type":"blocks","created_at":"2025-11-09T16:46:40.275734+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-4xj","depends_on_id":"wavesurfer.js-919","type":"blocks","created_at":"2025-11-09T16:46:40.316448+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-54t","content_hash":"011b3563d1f11e52feaf692c3f16b4dbfbfe73d8051e759753389993eba9f68b","title":"Add feature flag for new renderer","description":"Add feature flag to enable new reactive renderer alongside old one.\n\n## Implementation\nAdd to WaveSurferOptions:\n```typescript\nexport type WaveSurferOptions = {\n  // ... existing options\n  \n  /** Use new reactive renderer (experimental) */\n  useReactiveRenderer?: boolean\n}\n```\n\n## Constructor Logic\n```typescript\nconstructor(options: WaveSurferOptions) {\n  // ... existing setup\n  \n  // Create appropriate renderer\n  if (options.useReactiveRenderer) {\n    const { state, actions } = createWaveSurferState()\n    this.state = state\n    this.actions = actions\n    this.renderer = new DeclarativeRenderer(container, state, options)\n  } else {\n    // Old renderer (default)\n    this.renderer = new Renderer(options, audioElement)\n  }\n}\n```\n\n## Testing Strategy\nRun all examples with both renderers:\n```javascript\n// Test with old renderer (default)\nconst ws1 = WaveSurfer.create({ container: '#wave1' })\n\n// Test with new renderer\nconst ws2 = WaveSurfer.create({ \n  container: '#wave2',\n  useReactiveRenderer: true \n})\n```\n\n## Success Criteria\n- Both renderers produce identical visuals\n- Both pass all Cypress tests\n- Performance difference \u003c 5%\n- No console errors/warnings\n- Memory usage comparable\n\n## Documentation\nAdd to README:\n```markdown\n## Experimental: Reactive Renderer\n\nWe're working on a new reactive rendering engine. Try it out:\n\n```javascript\nconst ws = WaveSurfer.create({\n  container: '#waveform',\n  useReactiveRenderer: true  // Experimental!\n})\n```\n\nPlease report any issues!\n```\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:45.207549+01:00","updated_at":"2025-11-09T20:48:14.785987+01:00","closed_at":"2025-11-09T20:48:14.785987+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-54t","depends_on_id":"wavesurfer.js-gmg","type":"parent-child","created_at":"2025-11-09T14:23:45.24588+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-54t","depends_on_id":"wavesurfer.js-725","type":"blocks","created_at":"2025-11-09T14:23:45.283728+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-5qs","content_hash":"9132637a444261c6971b7bba991d54c30d03e04a997239a4134849fda760546b","title":"Phase 4, Task 6: Separate business logic from side effects in plugins","description":"**Goal:** Separate plugin business logic from side effects.\n\n**Implementation:**\n```typescript\n// Pure logic\nexport function calculateRegionBounds(\n  region: Region,\n  duration: number,\n  width: number\n): { x: number; width: number } {\n  return {\n    x: (region.start / duration) * width,\n    width: ((region.end - region.start) / duration) * width\n  }\n}\n\n// Side effects isolated\nclass RegionsPlugin {\n  private renderRegion(region: Region) {\n    const bounds = calculateRegionBounds(region, this.duration, this.width)\n    this.renderer.render(this.buildRegionTree(region, bounds))\n  }\n}\n```\n\n**Success Criteria:**\n- Logic separated\n- Testable\n- All plugins refactored","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:47:21.317034+01:00","updated_at":"2025-11-09T22:11:23.43884+01:00","closed_at":"2025-11-09T22:11:23.43884+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-5qs","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:48:14.083702+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-5ya","content_hash":"2d3e32237ac5c60724771bd1e77563d5c80a5a87d30c04261caf03ed3f917ff1","title":"Phase 4, Task 8: Create pure zoom calculation functions","description":"**Goal:** Pure zoom calculations.\n\n**Implementation:**\n```typescript\nexport function calculateZoom(\n  currentZoom: number,\n  delta: number,\n  centerTime: number,\n  duration: number\n): { zoom: number; scrollOffset: number } {\n  const newZoom = Math.max(1, Math.min(1000, currentZoom * (1 + delta)))\n  const scrollOffset = (centerTime / duration) * newZoom\n  return { zoom: newZoom, scrollOffset }\n}\n```\n\n**Success Criteria:**\n- Pure zoom logic\n- Maintains center point\n- Tests","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:47:21.41966+01:00","updated_at":"2025-11-09T22:01:29.143981+01:00","closed_at":"2025-11-09T22:01:29.143981+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-5ya","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:48:14.282397+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-61x","content_hash":"eaea2a4f053193b375c7b1570356023222ff86d1ea551cd1282e3db2d81ec485","title":"Implement reactive store (signals, computed, effect)","description":"Create the core reactive primitives that everything else builds on.\n\n## Implementation\nFile: src/reactive/store.ts\n\n### signal\u003cT\u003e(initialValue: T): WritableSignal\u003cT\u003e\n- Stores a value and notifies subscribers on change\n- Returns object with: value, set(), update(), subscribe()\n- Only notifies if value actually changes\n\n### computed\u003cT\u003e(fn, deps): Signal\u003cT\u003e\n- Automatically recalculates when dependencies change\n- Caches result until dependencies update\n- Read-only (no set/update methods)\n\n### effect(fn, deps): () =\u003e void\n- Runs automatically when dependencies change\n- Supports cleanup functions (returned from fn)\n- Returns unsubscribe function\n- Runs immediately on creation\n\n## TypeScript Types\n- Signal\u003cT\u003e interface\n- WritableSignal\u003cT\u003e extends Signal\u003cT\u003e\n- Proper generic constraints\n\n## Testing\n- Test signal updates notify subscribers\n- Test computed values update automatically\n- Test effect cleanup on unsubscribe\n- Test effect cleanup on re-run\n- Test no updates if value unchanged\n- Test multiple subscribers\n- Test circular dependency detection\n\n## Example Usage\n```typescript\nconst count = signal(0)\nconst double = computed(() =\u003e count.value * 2, [count])\neffect(() =\u003e console.log(double.value), [double])\ncount.set(5) // Logs: 10\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:04.831441+01:00","updated_at":"2025-11-09T14:47:43.369041+01:00","closed_at":"2025-11-09T14:47:43.369041+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-61x","depends_on_id":"wavesurfer.js-93k","type":"parent-child","created_at":"2025-11-09T14:23:04.870263+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-62i","content_hash":"cd6b34a9b5eb7dc72f9667fb8636defe2724de1f59ea839557ec299af013a018","title":"Phase 5, Task 3: Memory leak detection and prevention","description":"**Goal:** Ensure zero memory leaks in reactive system.\n\n**Detection Strategy:**\n```typescript\ndescribe('Memory Leaks', () =\u003e {\n  it('cleans up subscriptions on destroy', () =\u003e {\n    const initialHeap = performance.memory.usedJSHeapSize\n    \n    for (let i = 0; i \u003c 100; i++) {\n      const ws = WaveSurfer.create({ container: '#waveform' })\n      ws.load('audio.mp3')\n      ws.destroy()\n    }\n    \n    gc() // Force garbage collection\n    const finalHeap = performance.memory.usedJSHeapSize\n    expect(finalHeap - initialHeap).toBeLessThan(1024 * 1024) // \u003c1MB growth\n  })\n})\n```\n\n**Prevention Measures:**\n- Automatic subscription cleanup\n- WeakMap for caches\n- Effect disposal tracking\n- Event listener removal\n- Canvas cleanup\n\n**Tools:**\n- Chrome Memory Profiler\n- heap snapshots\n- Leak detector library\n\n**Dependencies:**\n- Blocks: All Phase 1-4 tasks\n\n**Success Criteria:**\n- Zero leaks in tests\n- Automatic cleanup works\n- Heap stable after destroy cycles\n- No dangling references","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T16:48:37.852497+01:00","updated_at":"2025-11-09T16:49:05.428409+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-62i","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:49:05.469669+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-6g9","content_hash":"18152c88a1d9dde80c88a1ac79092307d2c3c791dbc66ed42d2e3c722706f8ec","title":"Create documentation for reactive patterns","description":"Document reactive patterns for team and contributors.\n\n## Documentation Locations\n\n### JSDoc Comments\nAdd comprehensive JSDoc to:\n- src/reactive/store.ts (all exports)\n- src/reactive/event-streams.ts (all exports)\n- src/state/wavesurfer-state.ts (interfaces and factory)\n\nInclude:\n- Function purpose\n- Parameter descriptions\n- Return value description\n- Usage examples\n- Type parameters explanation\n\n### Code Examples\nCreate examples/reactive-demo.html showing:\n- Basic signal usage\n- Computed values\n- Effects with cleanup\n- Event streams\n- Complete mini-app using reactive patterns\n\n### Inline Documentation\nAdd comments explaining:\n- Why reactive over imperative\n- When to use signal vs computed\n- Effect cleanup patterns\n- Common pitfalls to avoid\n- Performance considerations\n\n### README Section\nAdd to main README.md:\n- Brief intro to reactive architecture\n- Link to examples\n- Migration timeline mention\n- Note about backward compatibility\n\n## Key Concepts to Explain\n\n### Signals\n- Reactive value containers\n- Notify subscribers automatically\n- Immutable from outside (use set/update)\n- Synchronous updates\n\n### Computed\n- Lazy evaluation\n- Automatic caching\n- Dependency tracking\n- Read-only\n\n### Effects\n- Side effects (DOM, network, etc.)\n- Automatic re-run on deps change\n- Cleanup on re-run or unsubscribe\n- Use for bridging to imperative code\n\n### Best Practices\n- Keep effects small and focused\n- Cleanup in effects always\n- Use computed for derived state\n- Don't mutate signal values directly\n- Avoid infinite loops (circular deps)\n\n## Deliverables\n- All code has JSDoc\n- examples/reactive-demo.html working\n- README.md updated\n- Comments explain 'why' not just 'what'","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:05.389762+01:00","updated_at":"2025-11-09T21:16:27.4276+01:00","closed_at":"2025-11-09T21:16:27.4276+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-6g9","depends_on_id":"wavesurfer.js-93k","type":"parent-child","created_at":"2025-11-09T14:23:05.431748+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-725","content_hash":"fbf47b002d71d28ab4271236cae3629b29f33ecba2e988f71a96ae89b9a7d002","title":"Implement DeclarativeRenderer class","description":"New renderer that uses reactive effects for automatic UI updates.\n\n## Implementation\nFile: src/renderer/declarative-renderer.ts\n\n### Class: DeclarativeRenderer\nReplacement for current Renderer that uses reactive patterns\n\n### Constructor\n```typescript\nconstructor(\n  container: HTMLElement,\n  state: WaveSurferState,\n  options: WaveSurferOptions\n)\n```\n\n### Setup Methods\n\n#### setupReactiveRendering()\nSets up all effects for automatic rendering:\n\n```typescript\n// Progress rendering\neffect(\n  () =\u003e this.renderProgress(state.progressPercent.value),\n  [state.progressPercent]\n)\n\n// Waveform rendering\neffect(\n  () =\u003e {\n    if (state.audioBuffer.value) {\n      this.renderWaveform(state.audioBuffer.value)\n    }\n  },\n  [state.audioBuffer]\n)\n\n// Zoom updates\neffect(\n  () =\u003e this.updateZoom(state.zoom.value),\n  [state.zoom]\n)\n\n// Scroll updates\neffect(\n  () =\u003e this.updateScroll(state.scrollPosition.value),\n  [state.scrollPosition]\n)\n```\n\n### Pure Rendering Methods\nThese do the actual DOM updates (no state reads):\n- renderProgress(percent: number)\n- renderWaveform(buffer: AudioBuffer)\n- updateZoom(zoom: number)\n- updateScroll(position: number)\n- renderCursor(position: number)\n\n### Lifecycle\n- constructor: Set up DOM structure\n- setupReactiveRendering(): Create all effects\n- destroy(): Cleanup all effects automatically\n\n## Key Differences from Old Renderer\nOLD: Manual calls to renderProgress()\nNEW: Automatic when state.currentTime changes\n\nOLD: Explicit render() calls\nNEW: Automatic when state.audioBuffer changes\n\nOLD: Timer-driven updates\nNEW: State-driven updates\n\n## Testing\n- Test progress renders at correct position\n- Test waveform renders when buffer set\n- Test zoom updates canvas\n- Test scroll updates position\n- Test automatic updates (no manual calls)\n- Test cleanup removes all effects\n- Test performance (frame rate)\n\n## Integration\nWorks alongside old renderer via feature flag:\n```typescript\nconst renderer = options.useReactiveRenderer\n  ? new DeclarativeRenderer(container, state, options)\n  : new Renderer(options, audioElement)\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:44.818439+01:00","updated_at":"2025-11-09T15:34:10.615983+01:00","closed_at":"2025-11-09T15:34:10.615983+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-725","depends_on_id":"wavesurfer.js-gmg","type":"parent-child","created_at":"2025-11-09T14:23:44.857396+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-725","depends_on_id":"wavesurfer.js-3mr","type":"blocks","created_at":"2025-11-09T14:23:44.896879+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-83o","content_hash":"10895520d97e4ab4e55618076080a17c0c82e230059abcfd213728e07860eeb5","title":"Create migration guide for users","description":"Create step-by-step migration guide for users upgrading from v7 to v8.\n\n## Migration Guide Sections\n\n### 1. What's New\n- Reactive architecture overview\n- Benefits for developers\n- Performance improvements\n- New features\n\n### 2. Breaking Changes\n- List all breaking changes (if any)\n- Why each change was made\n- Migration path for each\n\n### 3. Step-by-Step Migration\n- Update package version\n- Update initialization code\n- Update event handlers (if needed)\n- Update plugin usage (if needed)\n- Test your application\n\n### 4. Code Examples\nBefore/after for common patterns:\n- Basic usage\n- Event handling\n- Plugin usage\n- Custom rendering\n\n### 5. Troubleshooting\n- Common issues and solutions\n- Performance tips\n- Debugging reactive code\n\n### 6. Getting Help\n- GitHub issues\n- Discussions\n- Examples","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:58.699016+01:00","updated_at":"2025-11-09T14:39:14.194967+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-83o","depends_on_id":"wavesurfer.js-0ib","type":"parent-child","created_at":"2025-11-09T14:28:58.738262+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-857","content_hash":"5e252c9bae09a4bc09aab1daf86cd774ebc372faa665ee19516e4fc8bba83a68","title":"Update all code examples to reactive patterns","description":"Update all examples to showcase reactive patterns and verify they all work.\n\n## Examples to Update\n- examples/basic.html\n- examples/multi-track.html\n- examples/regions.html\n- examples/timeline.html\n- examples/minimap.html\n- examples/plugins/*.html\n\n## New Examples to Add\n- examples/reactive-demo.html (signals, computed, effects)\n- examples/reactive-plugin.html (building reactive plugin)\n- examples/performance.html (comparing old vs new)\n\n## For Each Example\n1. Update to use latest API\n2. Add comments explaining reactive patterns\n3. Showcase new features\n4. Verify works in all browsers\n5. Check performance","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:58.884904+01:00","updated_at":"2025-11-09T14:39:14.275213+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-857","depends_on_id":"wavesurfer.js-0ib","type":"parent-child","created_at":"2025-11-09T14:28:58.924505+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-8m5","content_hash":"db8e764ed9bc48f9607a7963b84b1ea272511e95c08f683383b8c8d3eea3bb71","title":"Phase 2, Task 7: Create declarative hover effects system","description":"**Goal:** Make the hover.ts plugin reactive, showing hover time and waveform information using declarative DOM updates.\n\n**Context:**\n- The hover plugin displays current time and waveform amplitude when hovering over the waveform\n- It uses DOM elements (not canvas) for the hover display\n- Currently uses imperative DOM manipulation\n- Should use reactive signals for declarative updates\n\n**Current Code (imperative):**\n```typescript\n// In hover.ts plugin\ncanvas.addEventListener('mousemove', (e) =\u003e {\n  const x = e.offsetX\n  const time = this.wavesurfer.getCurrentTime()\n  \n  // Imperative DOM updates\n  this.hoverElement.style.left = x + 'px'\n  this.hoverElement.textContent = this.formatTime(time)\n  this.hoverElement.style.display = 'block'\n})\n\ncanvas.addEventListener('mouseleave', () =\u003e {\n  this.hoverElement.style.display = 'none'\n})\n```\n\n**New Code (reactive with signals):**\n```typescript\n// In hover.ts plugin\nclass HoverPlugin {\n  private hoverPosition = signal\u003c{ x: number; time: number } | null\u003e(null)\n  \n  init(wavesurfer: WaveSurfer) {\n    // Set up reactive mouse tracking\n    const canvas = wavesurfer.getWrapper()\n    \n    const unsubMove = fromDOMEvent(canvas, 'mousemove').subscribe(e =\u003e {\n      const bounds = canvas.getBoundingClientRect()\n      const x = e.clientX - bounds.left\n      const time = wavesurfer.getCurrentTime()\n      this.hoverPosition.value = { x, time }\n    })\n    \n    const unsubLeave = fromDOMEvent(canvas, 'mouseleave').subscribe(() =\u003e {\n      this.hoverPosition.value = null\n    })\n    \n    // Declarative DOM updates via effect\n    effect(() =\u003e {\n      const hover = this.hoverPosition.value\n      if (hover) {\n        this.hoverElement.style.left = hover.x + 'px'\n        this.hoverElement.textContent = this.formatTime(hover.time)\n        this.hoverElement.style.display = 'block'\n      } else {\n        this.hoverElement.style.display = 'none'\n      }\n    })\n    \n    this.subscriptions.push(unsubMove, unsubLeave)\n  }\n}\n```\n\n**Benefits:**\n- Declarative: hover state → UI updates automatically\n- Reactive: uses signals for state management\n- Clean separation: event handling separate from rendering\n- Testable: can set hoverPosition.value directly in tests\n- No manual DOM manipulation in event handlers\n\n**Rendering Note:**\n- Hover plugin uses DOM elements (overlays), NOT canvas\n- Only waveform and spectrogram render on canvas\n- All interactive UI (regions, cursor, hover, etc.) uses DOM\n\n**Dependencies:**\n- Blocks: wavesurfer.js-uas (needs reactive system)\n\n**Success Criteria:**\n- Hover display works correctly\n- Uses signals for hover state\n- DOM updates are declarative (via effects)\n- No imperative style/content updates\n- Clean subscription cleanup","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-09T16:41:16.512747+01:00","updated_at":"2025-11-09T19:56:28.266188+01:00","closed_at":"2025-11-09T19:28:24.384096+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-8m5","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:41:31.560676+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-8m5","depends_on_id":"wavesurfer.js-uas","type":"blocks","created_at":"2025-11-09T16:41:31.599315+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-8ua","content_hash":"05e97702d95acf0a7297638a83f26cecd2770d1c048bfc7b95caeaa31b9ad44d","title":"Migrate Timeline plugin to reactive pattern","description":"Migrate Timeline plugin to reactive pattern. Auto-render on zoom/duration changes.","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:25:56.52166+01:00","updated_at":"2025-11-09T14:39:13.944971+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-8ua","depends_on_id":"wavesurfer.js-rzj","type":"parent-child","created_at":"2025-11-09T14:25:56.56141+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-8ua","depends_on_id":"wavesurfer.js-jwq","type":"blocks","created_at":"2025-11-09T14:25:56.60263+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-8y3","content_hash":"b648084abf2896967e19ca2417733b0b274b93bd12bd5f90bbb2e8ef84ef5fe5","title":"Create video tutorial series","description":"Create 3-5 short video tutorials explaining reactive architecture.\n\n## Videos to Create\n\n### 1. Introduction to Reactive WaveSurfer (5-7 min)\n- What's new in v8\n- Why reactive?\n- Quick demo\n- Benefits\n\n### 2. Understanding Signals and Computed Values (8-10 min)\n- What is a signal?\n- Creating and using signals\n- Computed values\n- Code examples\n- Common patterns\n\n### 3. Working with Effects (8-10 min)\n- What are effects?\n- When to use effects\n- Cleanup functions\n- Common pitfalls\n- Best practices\n\n### 4. Migrating from v7 to v8 (10-12 min)\n- Step-by-step migration\n- Code comparisons\n- Common issues\n- Testing your migration\n\n### 5. Building Reactive Plugins (Optional) (12-15 min)\n- Plugin architecture\n- Using reactive state\n- Examples\n- Best practices\n\n## Production\n- Screen recording with narration\n- Code examples with syntax highlighting\n- Clear, concise explanations\n- Upload to YouTube\n- Embed in documentation\n\n## Script Review\nHave team review scripts before recording","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:58.977994+01:00","updated_at":"2025-11-09T14:40:57.001454+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-8y3","depends_on_id":"wavesurfer.js-0ib","type":"parent-child","created_at":"2025-11-09T14:28:59.01792+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-8y3","depends_on_id":"wavesurfer.js-83o","type":"blocks","created_at":"2025-11-09T14:28:59.056987+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-919","content_hash":"6a038fee7691d8a10488b4c00ecb9bbad2158d2abc058be60c004c759bcb5349","title":"Phase 3, Task 3: Convert drag events to streams","description":"**Goal:** Implement drag operations as reactive event streams.\n\n**Current Code:**\n```typescript\nlet dragging = false\nlet dragStart = null\n\ncanvas.addEventListener('mousedown', (e) =\u003e {\n  dragging = true\n  dragStart = e.offsetX\n})\n\ncanvas.addEventListener('mousemove', (e) =\u003e {\n  const delta = e.offsetX - dragStart\n  // Update UI\n})\n\ncanvas.addEventListener('mouseup', () =\u003e {\n  dragging = false\n})\n```\n\n**New Code:**\n```typescript\n// Create drag stream\nfunction createDragStream(element: HTMLElement): EventStream\u003cDragEvent\u003e {\n  return new EventStream(emit =\u003e {\n    const mousedowns = fromDOMEvent(element, 'mousedown')\n    const mousemoves = fromDOMEvent(document, 'mousemove')\n    const mouseups = fromDOMEvent(document, 'mouseup')\n    \n    const unsubscribe = mousedowns.subscribe(down =\u003e {\n      const startX = down.offsetX\n      const startY = down.offsetY\n      \n      emit({ type: 'start', x: startX, y: startY })\n      \n      const moveUnsub = mousemoves.subscribe(move =\u003e {\n        emit({ \n          type: 'move', \n          x: move.clientX, \n          y: move.clientY,\n          deltaX: move.clientX - startX,\n          deltaY: move.clientY - startY\n        })\n      })\n      \n      const upUnsub = mouseups.subscribe(() =\u003e {\n        emit({ type: 'end' })\n        moveUnsub()\n        upUnsub()\n      })\n    })\n    \n    return unsubscribe\n  })\n}\n\n// Usage\nprivate setupDragStream() {\n  const drags = createDragStream(this.canvas)\n  \n  drags\n    .filter(e =\u003e e.type === 'move')\n    .throttle(16)\n    .subscribe(({ deltaX }) =\u003e {\n      this.scrollSignal.value += deltaX\n    })\n}\n```\n\n**Benefits:**\n- Declarative drag handling\n- Automatic mouseup cleanup\n- Easy to add drag constraints\n- Works for regions, timeline scrubbing, etc.\n\n**Use Cases:**\n- Region dragging (resize, move)\n- Timeline scrubbing\n- Waveform scrolling\n- Envelope point dragging\n- Any drag-based interaction\n\n**Note on Markers:**\nThere is no separate markers plugin. Markers are zero-width regions (where end = start). The Regions plugin handles all region/marker dragging.\n\n**Dependencies:**\n- Blocks: wavesurfer.js-ix6 (needs EventStream)\n\n**Success Criteria:**\n- All drag operations work\n- No memory leaks from forgotten mouseup handlers\n- Drag constraints work (bounds checking)\n- Multi-touch drag support","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:44:27.126977+01:00","updated_at":"2025-11-09T22:08:37.543333+01:00","closed_at":"2025-11-09T22:08:37.543333+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-919","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:44:48.621642+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-919","depends_on_id":"wavesurfer.js-ix6","type":"blocks","created_at":"2025-11-09T16:44:48.660261+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-93k","content_hash":"da40258c6fe70ae62db2225e0d8031b94347bac992865c2ca828afee0cdb7707","title":"Phase 1: Implement Reactive Foundation","description":"Add reactive infrastructure without breaking changes. This is the foundation for the entire refactoring.\n\n## Deliverables\n- src/reactive/store.ts (signals, computed, effect)\n- src/reactive/event-streams.ts (stream utilities)\n- src/state/wavesurfer-state.ts (centralized state)\n- Comprehensive unit tests (\u003e95% coverage)\n- Documentation for reactive patterns\n\n## Estimated Time\n2-3 weeks\n\n## Key Concepts\n**Signal**: Reactive value that notifies subscribers on change\n**Computed**: Derived value that auto-updates when dependencies change\n**Effect**: Side effect that runs automatically when dependencies change\n\n## Success Criteria\n- All tests passing\n- No breaking changes to existing code\n- Can be used alongside current implementation\n- Team understands reactive patterns\n- Ready to build Phase 2 on top","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:04.739762+01:00","updated_at":"2025-11-09T15:15:19.061336+01:00","closed_at":"2025-11-09T15:15:19.061341+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-93k","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T14:23:04.779339+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-97v","content_hash":"b2beca573771bb0d58fedcbda04e025c08870eabe6215d2c41d75dd1f9658a2e","title":"Phase 5, Task 7: Add reactive DevTools integration","description":"**Goal:** DevTools for debugging reactive system.\n\n**Features:**\n```typescript\n// DevTools integration\nwindow.__WAVESURFER_DEVTOOLS__ = {\n  signals: new Map(),\n  effects: new Set(),\n  streams: new Map(),\n  \n  trackSignal(name, signal) {\n    this.signals.set(name, signal)\n    console.log(`[Signal Created] ${name}`)\n  },\n  \n  logSignalChange(name, oldValue, newValue) {\n    console.log(`[Signal Change] ${name}:`, oldValue, '→', newValue)\n  },\n  \n  trackEffect(fn) {\n    this.effects.add(fn)\n    console.log('[Effect Registered]', fn.name)\n  },\n  \n  getSignalGraph() {\n    // Return dependency graph\n  }\n}\n```\n\n**UI Features:**\n- Signal value inspector\n- Effect execution timeline\n- Event stream visualizer\n- Render performance metrics\n- Dependency graph visualization\n\n**Dependencies:**\n- Blocks: Phase 1 tasks (reactive system)\n\n**Success Criteria:**\n- DevTools extension working\n- Signal inspection works\n- Performance metrics shown\n- Easy to debug","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-09T16:48:38.060049+01:00","updated_at":"2025-11-09T16:49:28.854633+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-97v","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:49:28.894121+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-980","content_hash":"27e08894d8508082dbe4a4930680310b77ccce46452bd020ab446b6e0502652c","title":"Phase 4: Refactor Player to expose reactive streams","description":"Refactor Player class to expose reactive streams instead of just internal signals.\n\n## Current State\nPlayer has internal reactive signals (_isPlaying, _currentTime, etc.) but doesn't expose them.\nWaveSurfer uses WaveSurferState which duplicates this.\n\n## Goal\nExpose Player's internal signals as public readonly streams, similar to Renderer.\n\n## Implementation\n```typescript\nclass Player {\n  // Public streams\n  public readonly isPlaying$: Signal\u003cboolean\u003e\n  public readonly currentTime$: Signal\u003cnumber\u003e\n  public readonly duration$: Signal\u003cnumber\u003e\n  public readonly volume$: Signal\u003cnumber\u003e\n  public readonly seeking$: Signal\u003cboolean\u003e\n  \n  // Keep EventEmitter for backward compat\n  // Emit events from signal subscriptions\n}\n```\n\n## Backward Compatibility\nKeep EventEmitter, emit from streams (same pattern as Renderer)\n\n## Dependencies\nNone - Player is independent","status":"closed","priority":0,"issue_type":"task","created_at":"2025-11-09T22:48:36.639079+01:00","updated_at":"2025-11-10T08:31:45.472868+01:00","closed_at":"2025-11-10T08:31:45.472868+01:00","source_repo":"."}
{"id":"wavesurfer.js-9dp","content_hash":"5d136a253ae63f98ffaece3f5813202ce2ed2d32b5309b496b7b25996771072f","title":"Test declarative renderer with existing examples","description":"Test new declarative renderer with all existing examples to ensure visual parity.\n\n## Test Matrix\n\n### Examples to Test\n- Basic waveform rendering\n- Multi-channel rendering\n- Bar rendering with gaps/radius\n- Progress and cursor rendering\n- Zoom functionality\n- Scroll and auto-scroll\n- Play/pause updates\n- Seek by clicking\n- Drag to seek\n- Timeline plugin\n- Regions plugin\n- Minimap plugin\n- All other official plugins\n\n### For Each Example\n1. Load with old renderer (baseline)\n2. Load with new renderer (useReactiveRenderer: true)\n3. Visual comparison (should be identical)\n4. Functional testing (all interactions work)\n5. Performance comparison (frame rate, memory)\n\n## Testing Process\n\n### Visual Regression\nUse Cypress image snapshots:\n```javascript\ndescribe('Reactive Renderer', () =\u003e {\n  it('matches old renderer visually', () =\u003e {\n    // Old renderer\n    cy.visit('/examples/basic.html')\n    cy.get('#waveform').matchImageSnapshot('old-renderer')\n    \n    // New renderer\n    cy.visit('/examples/basic.html?reactive=true')\n    cy.get('#waveform').matchImageSnapshot('new-renderer')\n    \n    // Compare snapshots\n  })\n})\n```\n\n### Functional Testing\n```javascript\ndescribe('Reactive Renderer Functionality', () =\u003e {\n  beforeEach(() =\u003e {\n    cy.visit('/examples/basic.html?reactive=true')\n  })\n  \n  it('plays and updates progress', () =\u003e {\n    cy.get('#play').click()\n    cy.wait(1000)\n    cy.get('.progress').should('have.css', 'width').and('not.eq', '0px')\n  })\n  \n  it('seeks on click', () =\u003e {\n    cy.get('.waveform').click(200, 50)\n    cy.get('.cursor').should('have.css', 'left')\n  })\n})\n```\n\n### Performance Testing\n```javascript\ndescribe('Reactive Renderer Performance', () =\u003e {\n  it('maintains 60fps during playback', () =\u003e {\n    // Measure frame rate\n    // Should be \u003e= 55fps (allowing small variance)\n  })\n  \n  it('does not leak memory', () =\u003e {\n    // Create/destroy instances\n    // Measure memory delta\n    // Should return to baseline\n  })\n})\n```\n\n## Success Criteria\n- All examples work identically\n- Visual snapshots match (within 1% difference)\n- Frame rate \u003e= 55fps during playback\n- No memory leaks (\u003c 1MB growth after 10 create/destroy cycles)\n- No console errors or warnings\n- All Cypress tests pass\n\n## Issues to Watch For\n- Timing differences (async rendering)\n- Race conditions (state updates)\n- Memory leaks (effect cleanup)\n- Performance degradation\n- Visual glitches or artifacts\n\n## Deliverable\nDocument in bd issue:\n- List of all examples tested\n- Pass/fail for each example\n- Performance metrics\n- Any issues found\n- Screenshots of problems","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:45.467213+01:00","updated_at":"2025-11-09T20:48:15.290307+01:00","closed_at":"2025-11-09T20:48:15.290307+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-9dp","depends_on_id":"wavesurfer.js-gmg","type":"parent-child","created_at":"2025-11-09T14:23:45.506534+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-9dp","depends_on_id":"wavesurfer.js-54t","type":"blocks","created_at":"2025-11-09T14:23:45.543799+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-9qq","content_hash":"9db7e4fd5503acd6a425490b1cb2845b43950adfc61f30da058b72a2e08ddcb1","title":"Phase 3, Task 9: Replace EventEmitter with event streams","description":"**Goal:** Replace traditional EventEmitter with reactive event streams.\n\n**Current Code:**\n```typescript\nclass WaveSurfer extends EventEmitter {\n  play() {\n    this.audio.play()\n    this.emit('play')\n  }\n  \n  on(event: string, handler: Function) {\n    super.on(event, handler)\n  }\n}\n\n// Usage\nwavesurfer.on('play', () =\u003e console.log('playing'))\n```\n\n**New Code:**\n```typescript\nclass WaveSurfer {\n  // Public event streams\n  public readonly play$: EventStream\u003cvoid\u003e\n  public readonly pause$: EventStream\u003cvoid\u003e\n  public readonly seek$: EventStream\u003cnumber\u003e\n  public readonly ready$: EventStream\u003cvoid\u003e\n  public readonly error$: EventStream\u003cError\u003e\n  \n  constructor() {\n    // Create streams from internal signals\n    this.play$ = this.playingSignal\n      .toStream()\n      .filter(playing =\u003e playing)\n      .map(() =\u003e undefined)\n    \n    this.pause$ = this.playingSignal\n      .toStream()\n      .map(() =\u003e undefined)\n    \n    this.seek$ = this.timeSignal.toStream()\n  }\n  \n  // Backward compatibility (optional)\n  on(event: string, handler: Function) {\n    const stream = this[`${event}$`]\n    return stream.subscribe(handler)\n  }\n}\n\n// Usage\nwavesurfer.play$.subscribe(() =\u003e console.log('playing'))\n\n// Or with backward compat\nwavesurfer.on('play', () =\u003e console.log('playing'))\n```\n\n**Benefits:**\n- Type-safe event subscriptions\n- Composable event streams\n- Automatic cleanup\n- Better testability\n\n**Migration:**\n- Keep backward compat for 1-2 versions\n- Deprecation warnings for `on()`\n- Migration guide for users\n\n**Dependencies:**\n- Blocks: wavesurfer.js-ix6\n\n**Success Criteria:**\n- All events available as streams\n- Backward compat works\n- Tests pass\n- Documentation updated","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-09T16:45:37.250586+01:00","updated_at":"2025-11-09T22:37:28.235316+01:00","closed_at":"2025-11-09T22:37:28.235316+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-9qq","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:46:53.804618+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-9qq","depends_on_id":"wavesurfer.js-ix6","type":"blocks","created_at":"2025-11-09T16:46:53.843756+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-9yn","content_hash":"9cc1ab102991a3f8959a049d4cdbade8ce203c61a428dc444f8ae8c479f31c30","title":"Phase 3: Transform Events to Reactive Streams","description":"Convert event-driven patterns to reactive streams. Remove Timer class and manual event subscriptions.\n\n## Goals\n- Eliminate Timer class (use reactive animation)\n- Convert media events to state updates\n- Reactive drag-to-seek with declarative debounce\n- Reactive scroll handling\n- State-driven event emission\n\n## Deliverables\n- Player class uses reactive state\n- No more Timer class\n- src/interactions/drag-handler.ts (reactive drag)\n- src/interactions/scroll-handler.ts (reactive scroll)\n- Automatic event emission from state changes\n\n## Estimated Time\n2-3 weeks\n\n## Architecture Change\nOLD: Event → Callback → State mutation → Manual render\nNEW: Event → State update → Automatic render (via effect)\n\n## Success Criteria\n- No Timer class in codebase\n- All media events convert to state updates\n- Drag/scroll use reactive streams\n- No manual event subscriptions in WaveSurfer\n- Performance maintained or improved","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:24:04.597315+01:00","updated_at":"2025-11-09T22:42:29.934873+01:00","closed_at":"2025-11-09T22:42:29.934873+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-9yn","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T14:24:04.636979+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-9yn","depends_on_id":"wavesurfer.js-93k","type":"blocks","created_at":"2025-11-09T14:24:04.674159+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-ahf","content_hash":"1d103cfca378aebced0aea4fb136a91a89e16c693bb74a910f3d6fe51277ff76","title":"Migrate waveform rendering to reactive pattern","description":"Migrate waveform canvas rendering to reactive pattern.\n\n## Current Implementation (Imperative)\n```typescript\n// Manual render calls\nthis.renderer.render(this.exportPeaks())\n// Called from load(), setOptions(), zoom(), etc.\n```\n\n## New Implementation (Reactive)\n```typescript\n// Automatic when data changes\neffect(\n  () =\u003e {\n    const buffer = state.audioBuffer.value\n    const peaks = state.peaks.value\n    if (buffer || peaks) {\n      this.renderWaveform(buffer, peaks)\n    }\n  },\n  [state.audioBuffer, state.peaks]\n)\n\n// Automatic on zoom change\neffect(\n  () =\u003e {\n    if (state.audioBuffer.value) {\n      this.reRenderWithZoom(state.zoom.value)\n    }\n  },\n  [state.zoom, state.audioBuffer]\n)\n\n// Automatic on options change\neffect(\n  () =\u003e {\n    if (state.audioBuffer.value) {\n      this.reRenderWithOptions(options)\n    }\n  },\n  [optionsSignal]\n)\n```\n\n## renderWaveform(buffer, peaks)\nPure rendering function:\n- Extract channel data\n- Calculate canvas dimensions\n- Draw waveform bars/lines\n- No state mutations\n- Returns nothing (side effect: DOM update)\n\n## Optimization Strategies\n- Canvas pooling for split channels\n- Offscreen rendering for smooth updates\n- Debounce rapid zoom changes\n- Web Worker for peak extraction (future)\n\n## Testing\n- Test waveform renders correctly\n- Test multi-channel rendering\n- Test bar vs line rendering\n- Test zoom re-renders\n- Test options changes re-render\n- Test performance with large files\n- Test memory usage\n\n## Integration\n- renderWaveform() works with both old and new renderer\n- Extract to src/core/waveform-drawing.ts (pure functions)\n- Renderer becomes thin wrapper calling pure functions\n- Easy to test rendering logic in isolation","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:45.077101+01:00","updated_at":"2025-11-09T20:48:14.276944+01:00","closed_at":"2025-11-09T20:48:14.276944+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-ahf","depends_on_id":"wavesurfer.js-gmg","type":"parent-child","created_at":"2025-11-09T14:23:45.116469+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-ahf","depends_on_id":"wavesurfer.js-725","type":"blocks","created_at":"2025-11-09T14:23:45.154579+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-av8","content_hash":"870f446ce8a80ee153fd0f28e06a83d4a72773f1298165db50896e97af62d71f","title":"Phase 5: Optimize reactive performance and minimize overhead","description":"Ensure the reactive architecture has minimal performance overhead and optimize hot paths.\n\n**Performance Goals:**\n- ≤5% performance overhead vs imperative code\n- No unnecessary re-renders\n- Efficient memory usage\n- Fast subscription/unsubscription\n\n**Optimization Areas:**\n\n1. **Subscription Performance:**\n```typescript\n// Use Set for O(1) subscription management\nclass SubscriptionManager {\n  private subscriptions = new Set\u003cSubscription\u003e()\n  \n  add(sub: Subscription) {\n    this.subscriptions.add(sub)\n  }\n  \n  remove(sub: Subscription) {\n    this.subscriptions.delete(sub)\n  }\n  \n  notify(state: WaveSurferState) {\n    // Batch notifications\n    for (const sub of this.subscriptions) {\n      sub.callback(state)\n    }\n  }\n}\n```\n\n2. **Memoization for Computed Values:**\n```typescript\nclass ComputedValue\u003cT\u003e {\n  private cachedValue: T | undefined\n  private isDirty = true\n  \n  get value(): T {\n    if (this.isDirty) {\n      this.cachedValue = this.computeFn()\n      this.isDirty = false\n    }\n    return this.cachedValue!\n  }\n  \n  invalidate() {\n    this.isDirty = true\n  }\n}\n```\n\n3. **Selective State Updates:**\n```typescript\n// Only notify subscribers affected by changed keys\nsetState(updates: Partial\u003cWaveSurferState\u003e) {\n  const changedKeys = Object.keys(updates)\n  const nextState = { ...this.state, ...updates }\n  \n  // Filter subscriptions by affected keys\n  const affectedSubs = this.subscriptions.filter(sub =\u003e\n    sub.keys.some(key =\u003e changedKeys.includes(key))\n  )\n  \n  this.state = nextState\n  affectedSubs.forEach(sub =\u003e sub.callback(this.state))\n}\n```\n\n4. **Debouncing High-Frequency Updates:**\n```typescript\n// Debounce cursor position updates\nconst debouncedCursorUpdate = debounce(\n  (time: number) =\u003e store.setState({ currentTime: time }),\n  16 // ~60fps\n)\n```\n\n5. **Object Pooling for Frequent Allocations:**\n```typescript\nclass StateUpdatePool {\n  private pool: Partial\u003cWaveSurferState\u003e[] = []\n  \n  acquire(): Partial\u003cWaveSurferState\u003e {\n    return this.pool.pop() || {}\n  }\n  \n  release(obj: Partial\u003cWaveSurferState\u003e) {\n    Object.keys(obj).forEach(key =\u003e delete obj[key])\n    this.pool.push(obj)\n  }\n}\n```\n\n**Performance Testing:**\n- Benchmark subscription notification speed\n- Profile memory usage over time\n- Measure render frequency\n- Test with large waveforms (\u003e10MB)\n- Test with many plugins (\u003e5)\n- Compare before/after metrics\n\n**Success Criteria:**\n- \u003c5% overhead in benchmarks\n- No memory leaks detected\n- No unnecessary renders\n- All existing performance tests pass\n- New performance tests added\n\n**Dependencies:**\n- All core refactoring complete\n- Plugins refactored\n- Renderer refactored\n\n**Estimated Effort:** 1 week","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T16:23:48.163162+01:00","updated_at":"2025-11-09T16:23:48.163162+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-av8","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:24:15.002047+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-av8","depends_on_id":"wavesurfer.js-26l","type":"blocks","created_at":"2025-11-09T16:24:43.452876+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-av8","depends_on_id":"wavesurfer.js-cg4","type":"blocks","created_at":"2025-11-09T16:24:43.490839+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-bg0","content_hash":"85ee31212812401f6a1aea9f7d21251841a399ee385c46859c5fabc10382b1a5","title":"Phase 4, Task 9: Add property-based testing for pure functions","description":"**Goal:** Property-based testing for pure functions.\n\n**Implementation:**\n```typescript\nimport { fc } from 'fast-check'\n\ndescribe('TimePixelConverter', () =\u003e {\n  it('roundtrip property', () =\u003e {\n    fc.assert(\n      fc.property(\n        fc.double({ min: 0, max: 1000 }), // time\n        fc.double({ min: 0, max: 10000 }), // duration\n        fc.integer({ min: 100, max: 2000 }), // width\n        (time, duration, width) =\u003e {\n          const pixel = timeToPixel(time, duration, width)\n          const backToTime = pixelToTime(pixel, duration, width)\n          return Math.abs(backToTime - time) \u003c 0.001\n        }\n      )\n    )\n  })\n})\n```\n\n**Success Criteria:**\n- Property tests for all pure functions\n- Edge cases covered\n- fast-check integrated","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-09T16:47:21.473932+01:00","updated_at":"2025-11-09T16:48:24.471049+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-bg0","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:48:24.511922+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-bn7","content_hash":"a940922512af0cb8eccd3f77353e408f26d4680b5433c452e72e06e20af53a71","title":"Write comprehensive API documentation","description":"Write comprehensive API documentation for all reactive APIs.\n\n## Documentation Needed\n\n### JSDoc Comments\nAll public APIs with:\n- Description\n- @param with types and descriptions\n- @returns with type and description\n- @example with code example\n- @see links to related APIs\n\n### API Reference\nDocument in website:\n- signal\u003cT\u003e(value)\n- computed\u003cT\u003e(fn, deps)\n- effect(fn, deps)\n- createWaveSurferState()\n- All state properties\n- All actions\n\n### Guides\n- Getting Started with Reactive WaveSurfer\n- Understanding Signals and Computed Values\n- Working with Effects\n- Creating Reactive Plugins\n- Performance Optimization Guide","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:58.604891+01:00","updated_at":"2025-11-09T14:39:14.155573+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-bn7","depends_on_id":"wavesurfer.js-0ib","type":"parent-child","created_at":"2025-11-09T14:28:58.644729+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-cg4","content_hash":"cc37749d5b4ab11f22b1e88288fe34687069c707c927c90dcc4c66099fea9382","title":"Phase 4: Refactor Renderer to expose reactive streams (not events)","description":"Transform the Renderer class from imperative event-driven to declarative reactive subscriptions.\n\n**Current State:**\n- Renderer responds to imperative render() calls\n- Manual coordination of drawing operations\n- Event-based rendering triggers\n\n**Target State:**\n- Subscribe to state changes from store\n- Declaratively define rendering dependencies\n- Automatic re-render on relevant state changes\n- Efficient batching of render operations\n\n**Implementation Steps:**\n\n1. Create reactive rendering system:\n```typescript\nclass Renderer {\n  private subscriptions: (() =\u003e void)[] = []\n  \n  constructor(\n    private container: HTMLElement,\n    private store: WaveSurferStore\n  ) {\n    this.setupReactiveRendering()\n  }\n  \n  private setupReactiveRendering() {\n    // Subscribe to rendering-relevant state\n    this.subscriptions.push(\n      this.store.subscribe(\n        ['waveform', 'peaks', 'currentTime', 'zoom', 'height'],\n        (state) =\u003e this.renderWaveform(state)\n      )\n    )\n    \n    this.subscriptions.push(\n      this.store.subscribe(\n        ['cursorStyle', 'cursorColor'],\n        (state) =\u003e this.updateCursorStyle(state)\n      )\n    )\n  }\n  \n  private renderWaveform(state: WaveSurferState) {\n    // Declarative rendering based on state\n    const { peaks, currentTime, zoom, height } = state\n    // Render implementation\n  }\n  \n  destroy() {\n    this.subscriptions.forEach(unsub =\u003e unsub())\n  }\n}\n```\n\n2. Implement render batching:\n```typescript\nclass RenderScheduler {\n  private pendingRender = false\n  \n  scheduleRender(renderFn: () =\u003e void) {\n    if (this.pendingRender) return\n    \n    this.pendingRender = true\n    requestAnimationFrame(() =\u003e {\n      renderFn()\n      this.pendingRender = false\n    })\n  }\n}\n```\n\n3. Add derived rendering state:\n```typescript\n// Compute canvas dimensions reactively\nconst canvasDimensions = computed(\n  [store.state.width, store.state.height, store.state.pixelRatio],\n  (width, height, ratio) =\u003e ({\n    width: width * ratio,\n    height: height * ratio,\n    style: { width: `${width}px`, height: `${height}px` }\n  })\n)\n```\n\n**Success Criteria:**\n- All rendering triggered by state changes\n- No manual render() calls except initial\n- Efficient batching prevents over-rendering\n- Clear dependency tracking for renders\n- Tests validate render frequency\n\n**Dependencies:**\n- Reactive store implementation\n- Computed values system\n- State management refactored\n\n**Estimated Effort:** 2 weeks","status":"closed","priority":0,"issue_type":"task","created_at":"2025-11-09T16:23:14.491644+01:00","updated_at":"2025-11-09T22:47:48.42732+01:00","closed_at":"2025-11-09T22:47:48.42732+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-cg4","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:24:14.922719+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-cg4","depends_on_id":"wavesurfer.js-jwq","type":"blocks","created_at":"2025-11-09T16:24:43.295924+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-cg4","depends_on_id":"wavesurfer.js-61x","type":"blocks","created_at":"2025-11-09T16:24:43.336939+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-cq2","content_hash":"786933e1da660db00b8510e721b440ae4080082ba020130a43502f437214cafc","title":"Phase 4, Task 4: Extract pure coordinate transformation functions","description":"**Goal:** Pure coordinate transformations.\n\n**Implementation:**\n```typescript\nexport function pixelToTime(pixel: number, duration: number, width: number, zoom: number = 1): number {\n  return (pixel / width) * duration / zoom\n}\n\nexport function timeToPixel(time: number, duration: number, width: number, zoom: number = 1): number {\n  return (time / duration) * width * zoom\n}\n\nexport function normalizeToViewport(\n  x: number,\n  y: number,\n  canvasRect: DOMRect\n): { x: number; y: number } {\n  return {\n    x: x - canvasRect.left,\n    y: y - canvasRect.top\n  }\n}\n```\n\n**Dependencies:**\n- Blocks: None\n\n**Success Criteria:**\n- All conversions pure\n- Invertible transforms\n- Property tests","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:47:21.214933+01:00","updated_at":"2025-11-09T21:58:50.054156+01:00","closed_at":"2025-11-09T21:58:50.054156+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-cq2","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:47:57.6741+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-deh","content_hash":"651231f233ec1ffd7f4aa9e96ff445a302d8593a4c243b5f4611a8fe2a206b80","title":"Phase 2, Task 10: Convert Spectrogram plugin to declarative rendering","description":"**Goal:** Refactor Spectrogram plugin to use declarative rendering with RenderTree.\n\n**Current Code:**\n```typescript\n// Imperative spectrogram rendering\nprivate drawSpectrogram() {\n  const { ctx, width, height } = this.getContext()\n  const imageData = ctx.createImageData(width, height)\n  \n  // Fill pixel by pixel\n  for (let i = 0; i \u003c this.fftData.length; i++) {\n    for (let j = 0; j \u003c this.fftData[i].length; j++) {\n      const value = this.fftData[i][j]\n      const color = this.colorMap(value)\n      const pixelIndex = (j * width + i) * 4\n      imageData.data[pixelIndex] = color.r\n      imageData.data[pixelIndex + 1] = color.g\n      imageData.data[pixelIndex + 2] = color.b\n      imageData.data[pixelIndex + 3] = 255\n    }\n  }\n  \n  ctx.putImageData(imageData, 0, 0)\n}\n```\n\n**New Code:**\n```typescript\n// 1. Add 'image' render node type\nexport type RenderNode = {\n  type: 'path' | 'rect' | 'line' | 'text' | 'group' | 'image'\n  // ...\n}\n\nexport type ImageProps = {\n  imageData: ImageData\n  x: number\n  y: number\n  width: number\n  height: number\n  opacity?: number\n}\n\n// 2. Build spectrogram as render tree\nprivate buildSpectrogramTree(): RenderNode {\n  const { width, height } = this.getContext()\n  \n  return {\n    type: 'image',\n    key: 'spectrogram',\n    props: {\n      imageData: this.computeSpectrogramImageData(),\n      x: 0,\n      y: 0,\n      width,\n      height,\n      opacity: this.options.opacity || 1\n    }\n  }\n}\n\n// 3. Cache computation results\nprivate spectrogramCache = computed(() =\u003e {\n  const fftData = this.fftDataSignal.value\n  const colorMap = this.colorMapSignal.value\n  return this.computeSpectrogramImageData(fftData, colorMap)\n})\n\nprivate buildSpectrogramTree(): RenderNode {\n  return {\n    type: 'image',\n    key: 'spectrogram',\n    props: {\n      imageData: this.spectrogramCache.value,\n      x: 0,\n      y: 0,\n      width: this.width,\n      height: this.height\n    }\n  }\n}\n```\n\n**Benefits:**\n- Spectrogram only recomputes when FFT data changes\n- Composites with other layers efficiently\n- Can apply effects (opacity, filters) declaratively\n- Easier to add features (color map changes, zoom)\n\n**Optimizations:**\n```typescript\n// Only recompute visible portion during scroll\nprivate buildSpectrogramTree(): RenderNode {\n  const visibleRange = this.getVisibleTimeRange()\n  const imageData = this.computePartialSpectrogram(visibleRange)\n  \n  return {\n    type: 'image',\n    key: 'spectrogram',\n    props: {\n      imageData,\n      x: visibleRange.start * this.pxPerSec,\n      y: 0,\n      width: imageData.width,\n      height: this.height\n    }\n  }\n}\n```\n\n**Dependencies:**\n- Blocks: wavesurfer.js-uas (needs RenderTree with image support)\n\n**Success Criteria:**\n- Spectrogram renders identically to current\n- Color map changes work\n- Opacity settings work\n- Performance is comparable or better\n- Supports all current spectrogram options","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-09T16:42:22.479146+01:00","updated_at":"2025-11-09T16:42:40.970791+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-deh","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:42:41.012225+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-deh","depends_on_id":"wavesurfer.js-uas","type":"blocks","created_at":"2025-11-09T16:42:41.051187+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-dj5","content_hash":"06f0e99ff64baa4a5247f668f7ab8780bf0a9c836d0e2f477800225a09d9e011","title":"Create pure calculation utilities","description":"Extract pure calculation functions used throughout codebase.\n\n## File: src/core/calculations.ts\n\n### Time/Progress Calculations\n```typescript\nexport function calculateProgress(currentTime: number, duration: number): number {\n  return duration \u003e 0 ? currentTime / duration : 0\n}\n\nexport function calculateTimeFromProgress(progress: number, duration: number): number {\n  return progress * duration\n}\n\nexport function clampTime(time: number, duration: number): number {\n  return Math.max(0, Math.min(duration, time))\n}\n```\n\n### Zoom Calculations\n```typescript\nexport function calculateZoomWidth(\n  duration: number,\n  minPxPerSec: number,\n  containerWidth: number\n): number {\n  const width = duration * minPxPerSec\n  return Math.max(containerWidth, width)\n}\n\nexport function calculateMinPxPerSec(\n  duration: number,\n  targetWidth: number\n): number {\n  return targetWidth / duration\n}\n```\n\n### Scroll Calculations\n```typescript\nexport interface ScrollPercentages {\n  startX: number  // 0-1\n  endX: number    // 0-1\n}\n\nexport function calculateScrollPercentages(params: {\n  scrollLeft: number\n  scrollWidth: number\n  clientWidth: number\n}): ScrollPercentages {\n  const { scrollLeft, scrollWidth, clientWidth } = params\n  return {\n    startX: scrollLeft / scrollWidth,\n    endX: (scrollLeft + clientWidth) / scrollWidth\n  }\n}\n\nexport function calculateScrollPosition(\n  percentage: number,\n  scrollWidth: number\n): number {\n  return percentage * scrollWidth\n}\n```\n\n### Canvas Calculations\n```typescript\nexport function calculateCanvasSize(\n  containerWidth: number,\n  containerHeight: number,\n  pixelRatio: number\n): { width: number; height: number } {\n  return {\n    width: Math.ceil(containerWidth * pixelRatio),\n    height: Math.ceil(containerHeight * pixelRatio)\n  }\n}\n```\n\n### Position Calculations\n```typescript\nexport function getRelativePointerPosition(\n  rect: DOMRect,\n  clientX: number,\n  clientY: number\n): [x: number, y: number] {\n  return [\n    (clientX - rect.left) / rect.width,\n    (clientY - rect.top) / rect.height\n  ]\n}\n\nexport function clampToUnit(value: number): number {\n  return Math.max(0, Math.min(1, value))\n}\n```\n\n## Benefits\n- Pure functions (no side effects)\n- Easy to test\n- Reusable across codebase\n- Type-safe\n- Self-documenting\n\n## Testing\n- Test all functions with various inputs\n- Test edge cases (0, negative, very large numbers)\n- Test rounding/precision\n- Test with TypeScript strict mode\n- Add JSDoc examples that double as tests","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:25:55.984559+01:00","updated_at":"2025-11-09T14:37:46.003016+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-dj5","depends_on_id":"wavesurfer.js-rzj","type":"parent-child","created_at":"2025-11-09T14:25:56.024051+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-djl","content_hash":"8dfb3b74e47e4c2957ac3ab2967f8b57d99ad8a10b7f71ed760698896422749a","title":"Phase 5, Task 2: Performance benchmarking and optimization","description":"**Goal:** Benchmark and optimize reactive system performance.\n\n**Benchmarks:**\n- Render performance (60fps maintained)\n- Memory usage (≤5% overhead)\n- Signal update latency (\u003c1ms)\n- Large dataset handling (1hr+ audio)\n- Many regions (1000+)\n- Plugin overhead\n- Initial load time\n\n**Optimizations:**\n- Memoization where beneficial\n- Virtual scrolling for large datasets\n- Worker thread offloading\n- Canvas layer optimization\n- Effect batching\n- Efficient dirty tracking\n\n**Performance Scenarios:**\n1. Playback with cursor updates (60fps)\n2. Zoom/scroll interactions (smooth)\n3. Region/marker manipulation (1000+ regions)\n4. Large waveform rendering (1hr+ audio)\n5. Plugin initialization overhead\n6. Memory usage during long sessions\n\n**Tools:**\n- Chrome DevTools Performance\n- Memory profiler\n- Custom benchmark suite\n- Lighthouse\n- React DevTools Profiler (adapted for signals)\n\n**Note on Regions/Markers:**\n- Markers are zero-width regions (no separate plugin)\n- Test with 1000+ regions including both standard and zero-width\n- Ensure DOM-based region rendering performs well\n\n**Dependencies:**\n- Blocks: All Phase 1-4 tasks\n\n**Success Criteria:**\n- ≤5% performance overhead vs imperative\n- 60fps during playback\n- No memory leaks\n- Fast initial load\n- Handles 1000+ regions smoothly\n- Worker offloading improves decode time","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T16:48:37.801316+01:00","updated_at":"2025-11-09T19:57:30.508394+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-djl","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:48:50.367336+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-dky","content_hash":"a944ef0de8e2119b08875b15b3c6a18082c94bbe5ed237f2035f4d22caa63a89","title":"Refactor Player class to use reactive state","description":"Refactor Player class to use reactive state instead of imperative callbacks.\n\n## Current Implementation (Imperative)\n```typescript\nclass Player {\n  // Manual event subscriptions\n  this.onMediaEvent('play', () =\u003e {\n    this.emit('play')\n    this.timer.start()\n  })\n  \n  this.onMediaEvent('pause', () =\u003e {\n    this.emit('pause')\n    this.timer.stop()\n  })\n}\n```\n\n## New Implementation (Reactive)\n```typescript\nclass ReactivePlayer\u003cT\u003e extends EventEmitter\u003cT\u003e {\n  // Reactive state\n  private _isPlaying = signal(false)\n  private _currentTime = signal(0)\n  private _duration = signal(0)\n  private _volume = signal(1)\n  \n  // Public getters return signals\n  get isPlaying() { return this._isPlaying }\n  get currentTime() { return this._currentTime }\n  get duration() { return this._duration }\n  get volume() { return this._volume }\n  \n  constructor(options: PlayerOptions) {\n    super()\n    this.media = options.media || document.createElement('audio')\n    this.setupReactiveMediaEvents()\n    this.setupEventBridge()\n  }\n  \n  private setupReactiveMediaEvents() {\n    // Convert media events to state updates\n    this.media.addEventListener('play', () =\u003e {\n      this._isPlaying.set(true)\n    })\n    \n    this.media.addEventListener('pause', () =\u003e {\n      this._isPlaying.set(false)\n    })\n    \n    this.media.addEventListener('timeupdate', () =\u003e {\n      this._currentTime.set(this.media.currentTime)\n    })\n    \n    this.media.addEventListener('durationchange', () =\u003e {\n      this._duration.set(this.media.duration)\n    })\n    \n    this.media.addEventListener('volumechange', () =\u003e {\n      this._volume.set(this.media.volume)\n    })\n  }\n  \n  private setupEventBridge() {\n    // Automatically emit wavesurfer events when state changes\n    this._isPlaying.subscribe(playing =\u003e {\n      this.emit(playing ? 'play' : 'pause')\n    })\n    \n    this._currentTime.subscribe(time =\u003e {\n      this.emit('timeupdate', time)\n    })\n  }\n}\n```\n\n## Benefits\n- State is observable from anywhere\n- No manual event forwarding\n- Can create computed values (e.g., isReady)\n- Automatic event emission\n- Easier to test (just check state values)\n\n## Migration Strategy\n1. Add reactive properties alongside existing code\n2. Sync reactive state with existing state\n3. Gradually migrate components to use reactive state\n4. Remove old state management in Phase 4\n\n## Testing\n- Test media events update state correctly\n- Test state changes emit events\n- Test play/pause toggle isPlaying\n- Test timeupdate updates currentTime\n- Test volume changes update volume signal\n- Test multiple subscribers work\n- Test cleanup removes listeners","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:24:04.725391+01:00","updated_at":"2025-11-09T21:19:15.546553+01:00","closed_at":"2025-11-09T21:19:15.546553+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-dky","depends_on_id":"wavesurfer.js-9yn","type":"parent-child","created_at":"2025-11-09T14:24:04.763073+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-drf","content_hash":"b2b6515ffe5b908e3c849015be5eace02edef2ffbc5d51a254fa16e9f5734610","title":"Convert media events to state bridges","description":"Convert HTMLMediaElement events to reactive state updates.\n\n## Bridge Function\n```typescript\nfunction bridgeMediaEvents(\n  media: HTMLMediaElement,\n  actions: WaveSurferActions\n): () =\u003e void {\n  const listeners: Array\u003c() =\u003e void\u003e = []\n  \n  const addListener = \u003cK extends keyof HTMLMediaElementEventMap\u003e(\n    event: K,\n    handler: (e: HTMLMediaElementEventMap[K]) =\u003e void\n  ) =\u003e {\n    media.addEventListener(event, handler)\n    listeners.push(() =\u003e media.removeEventListener(event, handler))\n  }\n  \n  // State updates from media events\n  addListener('play', () =\u003e actions.setPlaying(true))\n  addListener('pause', () =\u003e actions.setPlaying(false))\n  addListener('seeking', () =\u003e actions.setSeeking(true))\n  addListener('seeked', () =\u003e actions.setSeeking(false))\n  \n  addListener('timeupdate', () =\u003e {\n    actions.setCurrentTime(media.currentTime)\n  })\n  \n  addListener('durationchange', () =\u003e {\n    actions.setDuration(media.duration)\n  })\n  \n  addListener('volumechange', () =\u003e {\n    actions.setVolume(media.volume)\n  })\n  \n  addListener('ratechange', () =\u003e {\n    actions.setPlaybackRate(media.playbackRate)\n  })\n  \n  addListener('loadedmetadata', () =\u003e {\n    actions.setDuration(media.duration)\n  })\n  \n  addListener('ended', () =\u003e {\n    actions.setPlaying(false)\n    actions.setCurrentTime(actions.duration)\n  })\n  \n  // Return cleanup function\n  return () =\u003e listeners.forEach(cleanup =\u003e cleanup())\n}\n```\n\n## Usage\n```typescript\nclass WaveSurfer {\n  constructor() {\n    // Bridge media events to state\n    const cleanup = bridgeMediaEvents(this.media, this.actions)\n    this.subscriptions.push(cleanup)\n  }\n}\n```\n\n## Benefits\n- Single place for all media → state mappings\n- Automatic state sync\n- Easy to test (mock media events)\n- Clear data flow\n- Centralized cleanup\n\n## Testing\n- Test each media event updates correct state\n- Test cleanup removes all listeners\n- Test multiple events in sequence\n- Test rapid event firing","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:24:05.129518+01:00","updated_at":"2025-11-09T22:21:40.48034+01:00","closed_at":"2025-11-09T22:21:40.48034+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-drf","depends_on_id":"wavesurfer.js-9yn","type":"parent-child","created_at":"2025-11-09T14:24:05.169309+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-drf","depends_on_id":"wavesurfer.js-dky","type":"blocks","created_at":"2025-11-09T14:24:05.207883+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-e3a","content_hash":"d255e2d182b216d1fc7caffb47c246c934414263dab161394710617dff70e8a2","title":"Create migration guide for plugin authors","description":"Create migration guide for plugin authors to update plugins for reactive architecture.\n\n## Plugin Migration Guide\n\n### Understanding Changes\n- How reactive state works\n- Benefits for plugins\n- Backward compatibility\n\n### Migration Steps\n1. Update imports\n2. Use wavesurfer.state instead of getters\n3. Use effects instead of event listeners\n4. Update rendering to be reactive\n5. Test thoroughly\n\n### Code Examples\nMigrate each pattern:\n- Reading current time (OLD vs NEW)\n- Listening for changes (OLD vs NEW)\n- Updating plugin UI (OLD vs NEW)\n- Cleanup (OLD vs NEW)\n\n### Adapter Usage\nFor plugins that can't migrate yet:\n- How to use plugin adapter\n- When to use vs migrate\n- Performance considerations\n\n### Best Practices\n- Use computed for derived state\n- Keep effects focused\n- Always cleanup\n- Test with both old and new wavesurfer","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:58.792396+01:00","updated_at":"2025-11-09T14:39:14.236673+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-e3a","depends_on_id":"wavesurfer.js-0ib","type":"parent-child","created_at":"2025-11-09T14:28:58.831998+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-e7m","content_hash":"49f873f59edf9842999a0d32e5ada6abca159003e87be29d191a2ce9a0f47c2b","title":"Phase 3, Task 5: Convert keyboard events to streams","description":"**Goal:** Keyboard interactions as reactive streams.\n\n**Implementation:**\n```typescript\nprivate setupKeyboardStreams() {\n  const keydowns = fromDOMEvent(document, 'keydown')\n  \n  // Space = play/pause\n  keydowns\n    .subscribe(e =\u003e {\n      e.preventDefault()\n    })\n  \n  // Arrow keys = seek\n  keydowns\n    .filter(e =\u003e ['ArrowLeft', 'ArrowRight'].includes(e.code))\n    .throttle(100)\n    .subscribe(e =\u003e {\n      const delta = e.code === 'ArrowLeft' ? -1 : 1\n      this.timeSignal.value += delta\n    })\n  \n  // +/- = zoom\n  keydowns\n    .filter(e =\u003e ['+', '-'].includes(e.key))\n    .subscribe(e =\u003e {\n      const factor = e.key === '+' ? 1.2 : 0.8\n      this.zoomSignal.value *= factor\n    })\n}\n```\n\n**Dependencies:**\n- Blocks: wavesurfer.js-ix6\n\n**Success Criteria:**\n- All keyboard shortcuts work\n- No conflicts with page shortcuts\n- Configurable key bindings","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:45:00.509559+01:00","updated_at":"2025-11-09T21:47:18.243991+01:00","closed_at":"2025-11-09T21:47:18.243991+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-e7m","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:46:08.920077+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-e7m","depends_on_id":"wavesurfer.js-ix6","type":"blocks","created_at":"2025-11-09T16:46:08.958792+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-ea4","content_hash":"2b02e696264881320102c0d8271ef86a7cdde9465f72ee7e872b120d45f9a131","title":"Phase 4: Refactor WaveSurfer to use reactive streams internally","description":"Replace EventEmitter callbacks in WaveSurfer with reactive effect() subscriptions.\n\n## Current State\nWaveSurfer uses .on() callbacks to subscribe to Renderer and Player events:\n```typescript\nthis.renderer.on('click', (x, y) =\u003e {...})\nthis.renderer.on('drag', (x) =\u003e {...})\n```\n\n## Goal\nUse reactive effects instead of callbacks:\n```typescript\neffect(() =\u003e {\n  const click = this.renderer.click$.value\n  if (click) {\n    this.seekTo(click.x)\n    this.emit('click', click.x, click.y)\n  }\n}, [this.renderer.click$])\n```\n\n## Benefits\n- Fully reactive architecture end-to-end\n- Consistent with reactive state pattern\n- Better composability\n- Automatic cleanup\n\n## Dependencies\n- Depends on: wavesurfer.js-980 (Player streams)\n- Depends on: wavesurfer.js-cg4 (Renderer streams - DONE)\n\n## Implementation Plan\n1. Replace initRendererEvents() callbacks with effects\n2. Replace Player event subscriptions with effects  \n3. Keep public EventEmitter API (emit events from state)\n4. Test thoroughly","notes":"Successfully refactored WaveSurfer to use reactive streams internally. \n\nKey changes:\n1. Replaced EventEmitter callbacks in initRendererEvents() with reactive effect() subscriptions\n2. All renderer events (click, dblclick, scroll, drag, render, rendered, resize) now use reactive streams  \n3. Made scrollStream public in Renderer class to expose scroll percentages/bounds\n4. Updated test mock to include reactive stream properties (click$, dblclick$, drag$, resize$, render$, rendered$)\n5. Public EventEmitter API maintained for backward compatibility\n\nAll tests passing (386 passed). WaveSurfer now has fully reactive architecture end-to-end.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-11-09T22:48:49.702904+01:00","updated_at":"2025-11-10T09:24:58.61689+01:00","closed_at":"2025-11-10T09:24:58.616902+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-ea4","depends_on_id":"wavesurfer.js-980","type":"blocks","created_at":"2025-11-09T22:48:57.32573+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-ed4","content_hash":"e3ae4a3b449aeffdf466998d7376638ff3f00102680bf7fa00c210a139ddf081","title":"Phase 2, Task 5: Convert Regions plugin rendering to declarative","description":"**Goal:** Make Regions plugin rendering more declarative/reactive while keeping DOM-based rendering.\n\n**Current Issues:**\n1. Imperative `renderPosition()` called manually throughout\n2. Direct DOM style mutations in multiple places\n3. No reactive state management - manual update tracking\n4. Event handlers mixed with rendering logic\n5. Side effects scattered across methods\n\n**Refactor Strategy:**\n\n**1. Introduce Reactive Region State:**\n```typescript\nclass SingleRegion {\n  // Convert to signals\n  private _start = signal(params.start)\n  private _end = signal(params.end)\n  private _color = signal(params.color)\n  private _drag = signal(params.drag ?? true)\n  private _resize = signal(params.resize ?? true)\n  \n  // Public getters/setters\n  get start() { return this._start() }\n  set start(v) { this._start.set(v) }\n  \n  // Computed values\n  private _position = computed(() =\u003e ({\n    left: (this._start() / this.totalDuration) * 100,\n    right: ((this.totalDuration - this._end()) / this.totalDuration) * 100\n  }))\n  \n  private _isMarker = computed(() =\u003e this._start() === this._end())\n}\n```\n\n**2. Declarative Rendering with Effects:**\n```typescript\nprivate initElement(): HTMLElement {\n  const element = createElement('div', {\n    style: {\n      position: 'absolute',\n      pointerEvents: 'all'\n      // Initial static styles only\n    }\n  })\n  \n  // Effect: Update position reactively\n  this.subscriptions.push(\n    effect(() =\u003e {\n      const pos = this._position()\n      element.style.left = `${pos.left}%`\n      element.style.right = `${pos.right}%`\n    })\n  )\n  \n  // Effect: Update background color\n  this.subscriptions.push(\n    effect(() =\u003e {\n      const isMarker = this._isMarker()\n      const color = this._color()\n      element.style.backgroundColor = isMarker ? 'none' : color\n      element.style.borderLeft = isMarker ? `2px solid ${color}` : 'none'\n    })\n  )\n  \n  // Effect: Update cursor based on drag state\n  this.subscriptions.push(\n    effect(() =\u003e {\n      element.style.cursor = this._drag() ? 'grab' : 'default'\n    })\n  )\n  \n  // Effect: Manage resize handles\n  this.subscriptions.push(\n    effect(() =\u003e {\n      const isMarker = this._isMarker()\n      const resize = this._resize()\n      \n        this.addResizeHandles(element)\n      } else {\n        this.removeResizeHandles(element)\n      }\n    })\n  )\n  \n  return element\n}\n```\n\n**3. Clean Separation of Concerns:**\n```typescript\n// Pure functions for calculations\nprivate calculatePosition(start: number, end: number, duration: number) {\n  return {\n    left: (start / duration) * 100,\n    right: ((duration - end) / duration) * 100\n  }\n}\n\n// Update methods just set signal values\nprivate onMove(dx: number) {\n  const deltaSeconds = this.calculateDelta(dx)\n  this._start.set(this.clampPosition(this.start + deltaSeconds))\n  this._end.set(this.clampPosition(this.end + deltaSeconds))\n  this.emit('update')\n}\n\nprivate onResize(dx: number, side: UpdateSide) {\n  const deltaSeconds = this.calculateDelta(dx)\n  \n  if (side === 'start') {\n    const newStart = this.clampPosition(this.start + deltaSeconds)\n    if (this.isValidLength(newStart, this.end)) {\n      this._start.set(newStart)\n    }\n  } else {\n    const newEnd = this.clampPosition(this.end + deltaSeconds)\n    if (this.isValidLength(this.start, newEnd)) {\n      this._end.set(newEnd)\n    }\n  }\n  this.emit('update', side)\n}\n```\n\n**4. RegionsPlugin Reactive Updates:**\n```typescript\nclass RegionsPlugin {\n  private _duration = signal(0)\n  \n  private initWavesurferEvents() {\n    this.subscriptions.push(\n      this.wavesurfer.on('decode', (duration) =\u003e {\n        this._duration.set(duration)\n      })\n    )\n    \n    // Effect: Update all regions when duration changes\n    this.subscriptions.push(\n      effect(() =\u003e {\n        const duration = this._duration()\n        this.regions.forEach(region =\u003e {\n          region._setTotalDuration(duration)\n        })\n      })\n    )\n  }\n}\n```\n\n**Benefits:**\n- No manual `renderPosition()` calls - automatic updates\n- State changes trigger minimal DOM updates\n- Clear data flow: state → computed → effects → DOM\n- Easier to test (pure functions separate from effects)\n- Better performance (only affected styles update)\n\n**Success Criteria:**\n- Remove all manual `renderPosition()` calls\n- All region state as signals\n- DOM updates only via effects\n- All existing features work (drag, resize, content)\n- Tests pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:40:34.3368+01:00","updated_at":"2025-11-09T18:39:25.394126+01:00","closed_at":"2025-11-09T18:39:25.394126+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-ed4","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:40:49.979886+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-ed4","depends_on_id":"wavesurfer.js-uas","type":"blocks","created_at":"2025-11-09T16:40:50.018396+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-f29","content_hash":"92b0092b9d7c73f06343a262fa473a786dfe41b80d71a4b81cdf0c53c0a26e74","title":"Create bundle size monitoring","description":"Create bundle size monitoring with alerts if size increases significantly.\n\n## Bundle Size Check\nFile: scripts/check-bundle-size.js\n\n```javascript\nimport { readFileSync, statSync } from 'fs'\nimport gzipSize from 'gzip-size'\n\nconst files = [\n  'dist/wavesurfer.min.js',\n  'dist/wavesurfer.esm.js',\n  'dist/plugins/*.min.js'\n]\n\nconst limits = {\n  'wavesurfer.min.js': {\n    gzip: 45 * 1024, // 45 KB\n    raw: 120 * 1024  // 120 KB\n  }\n}\n\nfor (const file of files) {\n  const content = readFileSync(file)\n  const size = statSync(file).size\n  const gzip = await gzipSize(content)\n  \n  const limit = limits[file]\n  if (gzip \u003e limit.gzip) {\n    console.error(`❌ ${file} is too large: ${gzip} bytes (limit: ${limit.gzip})`)\n    process.exit(1)\n  }\n  \n  console.log(`✅ ${file}: ${gzip} bytes gzipped`)\n}\n```\n\n## CI Integration\n```yaml\n- name: Check bundle size\n  run: yarn check-bundle-size\n  \n- name: Comment PR with sizes\n  uses: andresz1/size-limit-action@v1\n  with:\n    github_token: ${{ secrets.GITHUB_TOKEN }}\n```\n\n## Alerts\n- Fail CI if over limit\n- Comment on PR with size comparison\n- Track size history","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:29:16.226226+01:00","updated_at":"2025-11-09T14:40:56.95978+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-f29","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T14:29:16.265419+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-f29","depends_on_id":"wavesurfer.js-93k","type":"blocks","created_at":"2025-11-09T14:29:16.30481+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-fx1","content_hash":"17fe2be483080a73596e02d0446531f25e48c3905d212021ce39b1f2421404e2","title":"Phase 2, Task 3: Convert Renderer drawBars to declarative","description":"**Goal:** Refactor bar-style waveform rendering to use declarative RenderTree.\n\n**Current Code:**\n```typescript\nprivate drawBars() {\n  const { ctx, width, height } = this.canvasWrapper.getContext()\n  const peaks = this.getPeaks()\n  \n  // Imperative loop drawing each bar\n  peaks.forEach((peak, i) =\u003e {\n    const x = (i / peaks.length) * width\n    const barHeight = peak * height\n    ctx.fillRect(x, height - barHeight, barWidth, barHeight)\n  })\n}\n```\n\n**New Code:**\n```typescript\nprivate buildBarsTree(peaks: AudioPeaks): RenderNode {\n  const { width, height } = this.canvasWrapper.getContext()\n  const barWidth = this.options.barWidth || 2\n  const barGap = this.options.barGap || 1\n  const barRadius = this.options.barRadius || 0\n  \n  return {\n    type: 'group',\n    key: 'bars',\n    children: peaks.map((peak, i) =\u003e {\n      const x = i * (barWidth + barGap)\n      const barHeight = Math.round(peak * height)\n      const isProgress = x \u003c width * this.progress\n      \n      return {\n        type: 'rect',\n        key: `bar-${i}`,\n        props: {\n          x,\n          y: height - barHeight,\n          width: barWidth,\n          height: barHeight,\n          fill: isProgress ? this.options.progressColor : this.options.waveColor,\n          radius: barRadius\n        }\n      }\n    })\n  }\n}\n```\n\n**Optimizations:**\n- Use keyed nodes for efficient diffing\n- Only update bars that change color on progress\n- Support rounded corners declaratively\n\n**Dependencies:**\n- Blocks: wavesurfer.js-uas (needs RenderTree)\n\n**Success Criteria:**\n- Bar rendering produces identical output\n- Progress updates only repaint affected bars\n- Supports all bar options (width, gap, radius, align)\n- Performance comparable to imperative version","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:40:01.161371+01:00","updated_at":"2025-11-09T18:11:57.475938+01:00","closed_at":"2025-11-09T18:11:57.475938+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-fx1","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:40:13.221852+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-fx1","depends_on_id":"wavesurfer.js-uas","type":"blocks","created_at":"2025-11-09T16:40:13.259821+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-gmg","content_hash":"99c864aec7a2a0f9ee4ec06f47b46614778b4e6f23cd341bf94515d0e8eb3804","title":"Phase 2: Implement Declarative Rendering Layer","description":"Create declarative renderer that automatically updates based on state changes.\n\n## Goals\n- Replace imperative DOM updates with reactive effects\n- Automatic UI updates when state changes\n- No manual render calls needed\n- Component-based UI structure\n\n## Deliverables\n- src/components/component.ts (component factory)\n- src/renderer/declarative-renderer.ts (new renderer)\n- Cursor and progress bar components\n- Feature flag to enable new renderer\n- Visual parity with old renderer\n\n## Estimated Time\n3-4 weeks\n\n## Architecture\nState → Computed → Effect → DOM Update (automatic)\n\n## Success Criteria\n- New renderer works alongside old\n- Feature flag toggles between renderers\n- All examples work with new renderer\n- No visual differences\n- Performance within 5% of old renderer","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:44.595425+01:00","updated_at":"2025-11-09T20:48:15.790891+01:00","closed_at":"2025-11-09T20:48:15.790891+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-gmg","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T14:23:44.635221+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-gmg","depends_on_id":"wavesurfer.js-93k","type":"blocks","created_at":"2025-11-09T14:23:44.672814+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-gmg","depends_on_id":"wavesurfer.js-190","type":"blocks","created_at":"2025-11-09T14:29:15.745125+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-isi","content_hash":"a04b51a4325c0d77848682c36b66c7c0c2f67bf76ec8d698d83b44b522e5d882","title":"Remove Timer class and use reactive animation","description":"Remove Timer class and replace with reactive animation loop.\n\n## Current Implementation (Timer Class)\n```typescript\n// src/timer.ts\nclass Timer extends EventEmitter\u003cTimerEvents\u003e {\n  private animationFrameId: number | null = null\n  private isRunning = false\n\n  start() {\n    if (this.isRunning) return\n    this.isRunning = true\n    const tick = () =\u003e {\n      this.emit('tick')\n      this.animationFrameId = requestAnimationFrame(tick)\n    }\n    tick()\n  }\n\n  stop() {\n    this.isRunning = false\n    if (this.animationFrameId !== null) {\n      cancelAnimationFrame(this.animationFrameId)\n    }\n  }\n}\n\n// Usage in wavesurfer.ts\nthis.timer = new Timer()\nthis.timer.on('tick', () =\u003e {\n  const currentTime = this.updateProgress()\n  this.emit('timeupdate', currentTime)\n})\n\nthis.onMediaEvent('play', () =\u003e this.timer.start())\nthis.onMediaEvent('pause', () =\u003e this.timer.stop())\n```\n\n## New Implementation (Reactive Effect)\n```typescript\n// No separate Timer class needed!\n\nclass WaveSurfer {\n  private setupReactiveAnimation() {\n    let rafId: number | null = null\n    \n    // Animation runs automatically while playing\n    effect(\n      () =\u003e {\n        const isPlaying = this.state.isPlaying.value\n        \n        if (isPlaying) {\n          // Start animation loop\n          const animate = () =\u003e {\n            // Read current time from media\n            const currentTime = this.media.currentTime\n            \n            // Update reactive state\n            this.actions.setCurrentTime(currentTime)\n            \n            // Continue loop\n            rafId = requestAnimationFrame(animate)\n          }\n          \n          animate()\n          \n          // Return cleanup function\n          return () =\u003e {\n            if (rafId !== null) {\n              cancelAnimationFrame(rafId)\n              rafId = null\n            }\n          }\n        }\n      },\n      [this.state.isPlaying]\n    )\n  }\n}\n\n// Progress rendering happens automatically via separate effect\neffect(\n  () =\u003e this.renderProgress(this.state.currentTime.value),\n  [this.state.currentTime]\n)\n\n// Event emission happens automatically\nthis.state.currentTime.subscribe(time =\u003e {\n  this.emit('timeupdate', time)\n  if (this.state.isPlaying.value) {\n    this.emit('audioprocess', time)\n  }\n})\n```\n\n## Benefits\n- No separate Timer class to maintain\n- Animation automatically starts/stops with playback\n- Automatic cleanup (effect handles it)\n- All updates driven by state\n- Can easily throttle/debounce if needed\n- Better separation of concerns\n- Easier to test\n\n## Migration Steps\n1. Add reactive animation effect\n2. Test that progress updates work\n3. Verify events still fire correctly\n4. Remove Timer class\n5. Remove timer-related subscriptions\n6. Update tests\n\n## Testing\n- Test animation runs while playing\n- Test animation stops when paused\n- Test animation restarts on play\n- Test cleanup cancels animation frame\n- Test progress updates smoothly\n- Test no memory leaks\n- Test performance (60fps maintained)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:24:04.816345+01:00","updated_at":"2025-11-09T21:24:01.587743+01:00","closed_at":"2025-11-09T21:24:01.587743+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-isi","depends_on_id":"wavesurfer.js-9yn","type":"parent-child","created_at":"2025-11-09T14:24:04.855352+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-isi","depends_on_id":"wavesurfer.js-dky","type":"blocks","created_at":"2025-11-09T14:24:04.893696+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-ix6","content_hash":"f9706a0bc941e0f6f12e2756e2ebb0524a5f7d0d4a7fbae58e64231322578955","title":"Phase 3, Task 1: Create event stream abstraction","description":"**Goal:** Create a reactive stream abstraction for handling DOM and audio events.\n\n**Implementation:**\n```typescript\n// src/events/EventStream.ts\n\nexport class EventStream\u003cT\u003e {\n  private listeners: Set\u003c(value: T) =\u003e void\u003e = new Set()\n  private destroyed = false\n  \n  constructor(\n    private setup: (emit: (value: T) =\u003e void) =\u003e () =\u003e void\n  ) {}\n  \n  subscribe(listener: (value: T) =\u003e void): () =\u003e void {\n    if (this.destroyed) throw new Error('Stream destroyed')\n    \n    // Lazy initialization\n      this.cleanup = this.setup(this.emit.bind(this))\n    }\n    \n    this.listeners.add(listener)\n    \n    return () =\u003e {\n      this.listeners.delete(listener)\n      // Auto cleanup when no listeners\n      if (this.listeners.size === 0 \u0026\u0026 this.cleanup) {\n        this.cleanup()\n        this.cleanup = null\n      }\n    }\n  }\n  \n  private emit(value: T) {\n    this.listeners.forEach(listener =\u003e listener(value))\n  }\n  \n  // Stream operators\n  map\u003cU\u003e(fn: (value: T) =\u003e U): EventStream\u003cU\u003e {\n    return new EventStream(emit =\u003e {\n      return this.subscribe(value =\u003e emit(fn(value)))\n    })\n  }\n  \n  filter(predicate: (value: T) =\u003e boolean): EventStream\u003cT\u003e {\n    return new EventStream(emit =\u003e {\n      return this.subscribe(value =\u003e {\n        if (predicate(value)) emit(value)\n      })\n    })\n  }\n  \n  throttle(ms: number): EventStream\u003cT\u003e {\n    return new EventStream(emit =\u003e {\n      let lastEmit = 0\n      return this.subscribe(value =\u003e {\n        const now = Date.now()\n        if (now - lastEmit \u003e= ms) {\n          emit(value)\n          lastEmit = now\n        }\n      })\n    })\n  }\n  \n  debounce(ms: number): EventStream\u003cT\u003e {\n    return new EventStream(emit =\u003e {\n      let timeout: any\n      return this.subscribe(value =\u003e {\n        clearTimeout(timeout)\n        timeout = setTimeout(() =\u003e emit(value), ms)\n      })\n    })\n  }\n  \n  merge\u003cU\u003e(other: EventStream\u003cU\u003e): EventStream\u003cT | U\u003e {\n    return new EventStream(emit =\u003e {\n      const unsub1 = this.subscribe(emit)\n      const unsub2 = other.subscribe(emit)\n      return () =\u003e {\n        unsub1()\n        unsub2()\n      }\n    })\n  }\n  \n  destroy() {\n    this.cleanup?.()\n    this.listeners.clear()\n    this.destroyed = true\n  }\n}\n\n// Helper to create streams from DOM events\nexport function fromDOMEvent\u003cK extends keyof HTMLElementEventMap\u003e(\n  element: HTMLElement,\n  eventName: K\n): EventStream\u003cHTMLElementEventMap[K]\u003e {\n  return new EventStream(emit =\u003e {\n    element.addEventListener(eventName, emit as any)\n    return () =\u003e element.removeEventListener(eventName, emit as any)\n  })\n}\n```\n\n**Example Usage:**\n```typescript\n// Mouse move stream with throttling\nconst mouseMoves = fromDOMEvent(canvas, 'mousemove')\n  .throttle(16) // ~60fps\n  .map(e =\u003e ({ x: e.offsetX, y: e.offsetY }))\n\n// Auto-cleanup subscription\nconst unsubscribe = mouseMoves.subscribe(pos =\u003e {\n  console.log('Mouse at', pos)\n})\n\n// Cleanup\nunsubscribe()\n```\n\n**Dependencies:**\n- Blocks: None (foundational)\n\n**Success Criteria:**\n- EventStream class works correctly\n- All operators (map, filter, throttle, debounce, merge) work\n- Automatic cleanup when no listeners\n- Memory leak tests pass\n- Performance tests pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:43:27.588923+01:00","updated_at":"2025-11-09T21:15:45.232154+01:00","closed_at":"2025-11-09T21:15:45.232154+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-ix6","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:43:44.024409+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-jgz","content_hash":"f34ce5dfa5dcedc06fcbabe15205a6c7d9aa11657947cfb2817b39df691bf5d0","title":"Migrate drag-to-seek to reactive streams","description":"Migrate drag-to-seek to reactive streams with declarative debounce.\n\n## Current Implementation (Imperative)\n```typescript\n// Manual debounce management\nlet debounce: ReturnType\u003ctypeof setTimeout\u003e | undefined\nconst unsubscribeDrag = this.renderer.on('drag', (relativeX) =\u003e {\n\n  // Update visual immediately\n  this.renderer.renderProgress(relativeX)\n\n  // Debounced seek\n  clearTimeout(debounce)\n  let debounceTime = 0\n  if (this.isPlaying()) {\n    debounceTime = 0\n  } else if (this.options.dragToSeek === true) {\n    debounceTime = 200\n  } else if (typeof this.options.dragToSeek === 'object') {\n    debounceTime = this.options.dragToSeek.debounceTime ?? 200\n  }\n\n  debounce = setTimeout(() =\u003e {\n    this.seekTo(relativeX)\n  }, debounceTime)\n\n  this.emit('interaction', relativeX * this.getDuration())\n  this.emit('drag', relativeX)\n})\n\n// Manual cleanup\nthis.subscriptions.push(() =\u003e {\n  clearTimeout(debounce)\n  unsubscribeDrag()\n})\n```\n\n## New Implementation (Reactive Streams)\nFile: src/interactions/drag-handler.ts\n\n```typescript\nclass DragHandler {\n  private dragPosition = signal\u003cnumber | null\u003e(null)\n  \n  constructor(\n    private element: HTMLElement,\n    private state: WaveSurferState,\n    private actions: WaveSurferActions,\n    private options: WaveSurferOptions\n  ) {\n    this.setupDragStream()\n  }\n  \n  private setupDragStream() {\n    // Convert drag events to stream\n    const dragStream = this.createDragStream(this.element)\n    \n    // Map to relative position\n    const relativePosition = map(dragStream, event =\u003e {\n      const rect = this.element.getBoundingClientRect()\n      return event.clientX / rect.width\n    })\n    \n    // Calculate debounce time based on state\n    const debounceTime = computed(\n      () =\u003e {\n        if (this.state.isPlaying.value) return 0\n        if (this.options.dragToSeek === true) return 200\n        if (typeof this.options.dragToSeek === 'object') {\n          return this.options.dragToSeek.debounceTime ?? 200\n        }\n        return 0\n      },\n      [this.state.isPlaying]\n    )\n    \n    // Debounce position updates\n    const debouncedPosition = debounce(relativePosition, debounceTime.value)\n    \n    // Visual update (immediate, not debounced)\n    effect(\n      () =\u003e {\n        const pos = relativePosition.value\n        if (pos !== null) {\n          this.updateDragVisual(pos)\n        }\n      },\n      [relativePosition]\n    )\n    \n    // Seek (debounced)\n    effect(\n      () =\u003e {\n        const pos = debouncedPosition.value\n        if (pos !== null) {\n          this.actions.setCurrentTime(pos * this.state.duration.value)\n        }\n      },\n      [debouncedPosition]\n    )\n  }\n  \n  private createDragStream(element: HTMLElement): Signal\u003cPointerEvent\u003e {\n    // Use makeDraggable from draggable.ts\n    // Convert to signal\n  }\n  \n  private updateDragVisual(position: number) {\n    // Pure rendering - just update UI\n  }\n}\n```\n\n## Benefits\n- Declarative debounce logic\n- No manual timeout management\n- Automatic cleanup\n- Visual updates immediate, seek debounced\n- Easy to test (pure functions)\n- Composable stream operators\n- Clear data flow\n\n## Testing\n- Test drag updates visual immediately\n- Test seek is debounced\n- Test debounce time changes based on isPlaying\n- Test cleanup removes listeners\n- Test multiple rapid drags\n- Test drag during playback (no debounce)\n- Test drag while paused (200ms debounce)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:24:04.946829+01:00","updated_at":"2025-11-09T21:27:04.471105+01:00","closed_at":"2025-11-09T21:27:04.471105+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-jgz","depends_on_id":"wavesurfer.js-9yn","type":"parent-child","created_at":"2025-11-09T14:24:04.98561+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-jwq","content_hash":"ef7635435e10d6e77523b6bead1611879d0500ec6aee6bf77569c47ac14d0116","title":"Refactor WaveSurfer class to thin shell","description":"Refactor WaveSurfer class to thin shell around reactive core. Keep backward compatibility.\n\n## Goal\nWaveSurfer becomes a lightweight wrapper that:\n1. Manages reactive state\n2. Calls pure functions\n3. Bridges to legacy events\n4. Handles I/O (media element, DOM)\n\nTarget: \u003c500 LOC (currently ~600 LOC)\n\n## New Architecture\n```typescript\nclass WaveSurfer extends EventEmitter\u003cWaveSurferEvents\u003e {\n  private state: WaveSurferState\n  private actions: WaveSurferActions\n  private renderer: DeclarativeRenderer\n  private media: HTMLMediaElement\n  private cleanups: Array\u003c() =\u003e void\u003e = []\n  \n  constructor(options: WaveSurferOptions) {\n    super()\n    \n    // Create reactive state\n    const { state, actions } = createWaveSurferState()\n    this.state = state\n    this.actions = actions\n    \n    // Create media element\n    this.media = this.createMediaElement(options)\n    \n    // Setup declarative renderer\n    this.renderer = new DeclarativeRenderer(\n      this.getContainer(options.container),\n      state,\n      options\n    )\n    \n    // Bridge media events to state\n    this.cleanups.push(bridgeMediaEvents(this.media, actions))\n    \n    // Bridge state to legacy events\n    this.setupEventBridge()\n    \n    // Setup reactive animation\n    this.setupAnimation()\n    \n    // Initialize plugins\n    this.initPlugins(options.plugins)\n    \n    // Load initial audio\n    if (options.url) {\n      this.load(options.url, options.peaks, options.duration)\n    }\n  }\n  \n  // Public API becomes thin wrappers around state/media\n  play() {\n    return this.media.play()  // State updates automatically\n  }\n  \n  pause() {\n    this.media.pause()  // State updates automatically\n  }\n  \n  seekTo(progress: number) {\n    const time = calculateTimeFromProgress(progress, this.state.duration.value)\n    this.media.currentTime = clampTime(time, this.state.duration.value)\n  }\n  \n  setTime(time: number) {\n    this.media.currentTime = clampTime(time, this.state.duration.value)\n  }\n  \n  // Getters read from state\n  getCurrentTime() { return this.state.currentTime.value }\n  getDuration() { return this.state.duration.value }\n  isPlaying() { return this.state.isPlaying.value }\n  getVolume() { return this.state.volume.value }\n  \n  // Setters update media/state\n  setVolume(volume: number) {\n    this.media.volume = clampToUnit(volume)\n  }\n  \n  setPlaybackRate(rate: number) {\n    this.media.playbackRate = rate\n  }\n  \n  // Load uses pure function\n  async load(url: string, peaks?: Float32Array[], duration?: number) {\n    const audioData = await loadAudio({ url, peaks, duration, ...options })\n    this.actions.setAudioBuffer(audioData.buffer)\n    this.actions.setPeaks(audioData.peaks)\n    this.actions.setDuration(audioData.duration)\n  }\n  \n  // Cleanup\n  destroy() {\n    this.cleanups.forEach(fn =\u003e fn())\n    this.renderer.destroy()\n    this.media.remove()\n    this.unAll()\n  }\n}\n```\n\n## Migration Strategy\n1. Add reactive state alongside existing code\n2. Gradually replace imperative code\n3. Test each change\n4. Remove old code once verified\n5. Ensure all tests still pass\n\n## Backward Compatibility\nALL existing public APIs must work:\n- Same method signatures\n- Same events emitted\n- Same timing of events\n- Plugins work unchanged\n\n## Testing\n- All existing tests must pass\n- Add tests for new reactive behavior\n- Test backward compatibility explicitly\n- Test memory cleanup\n- Performance benchmarks","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:25:56.211051+01:00","updated_at":"2025-11-09T22:33:06.531012+01:00","closed_at":"2025-11-09T22:33:06.531012+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-jwq","depends_on_id":"wavesurfer.js-rzj","type":"parent-child","created_at":"2025-11-09T14:25:56.250077+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-jwq","depends_on_id":"wavesurfer.js-l1e","type":"blocks","created_at":"2025-11-09T14:25:56.289676+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-jwq","depends_on_id":"wavesurfer.js-dj5","type":"blocks","created_at":"2025-11-09T14:25:56.328344+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-jxc","content_hash":"ea77cda1eb035dd521af516ef55d89d8be31c2c07e34bb3c9fc8e8475a5aac32","title":"Phase 5: Create comprehensive documentation and migration guide","description":"Document the new reactive architecture and provide migration guides for users upgrading from imperative version.\n\n**Documentation Areas:**\n\n1. **Architecture Overview:**\n- Explain reactive vs imperative approach\n- Document state flow and subscriptions\n- Diagram the architecture\n- Explain computed values and derived state\n\n2. **API Reference:**\n- Document new store API\n- Document subscription methods\n- Document computed values API\n- Document reactive plugin base class\n- Update all method signatures\n\n3. **Migration Guide:**\n\n```markdown\n# Migration Guide: v6 to v7 (Reactive Architecture)\n\n## Overview\nVersion 7 introduces a reactive architecture. Most existing code will work unchanged, but you can take advantage of new reactive features.\n\n## Breaking Changes\n\n### Event Listeners (Still Supported)\nEvent listeners still work but are now backed by reactive subscriptions:\n```javascript\n// Still works\nwavesurfer.on('audioprocess', (time) =\u003e {\n  console.log(time)\n})\n```\n\n### Direct State Access (New)\nYou can now subscribe to state changes directly:\n```javascript\n// New reactive API\nwavesurfer.subscribe(['currentTime'], ({ currentTime }) =\u003e {\n  console.log(currentTime)\n})\n```\n\n### Plugin Development (Changed)\nPlugins should extend ReactivePlugin:\n```javascript\nclass MyPlugin extends ReactivePlugin {\n  onInit() {\n    this.subscribe(['currentTime'], ({ currentTime }) =\u003e {\n      // React to time changes\n    })\n  }\n}\n```\n\n## Migration Steps\n\n1. Test your existing code - it should mostly work\n2. Replace manual state tracking with subscriptions\n3. Update custom plugins to use ReactivePlugin\n4. Remove manual render() calls\n5. Use computed values for derived state\n\n## Performance Benefits\n- Automatic cleanup prevents memory leaks\n- Efficient re-rendering\n- Better testability\n```\n\n4. **Code Examples:**\n- Basic subscription usage\n- Creating computed values\n- Plugin development\n- Performance optimization patterns\n- Testing reactive code\n\n5. **Troubleshooting Guide:**\n- Common migration issues\n- Debugging subscriptions\n- Performance profiling\n- Memory leak detection\n\n**Documentation Deliverables:**\n- Updated README.md\n- New ARCHITECTURE.md\n- MIGRATION.md guide\n- Updated API docs\n- JSDoc comments in code\n- Example projects updated\n\n**Success Criteria:**\n- All public APIs documented\n- Migration guide covers all breaking changes\n- Examples run and are tested\n- User feedback incorporated\n- Documentation reviewed by team\n\n**Dependencies:**\n- All implementation complete\n- All tests passing\n- Performance validated\n\n**Estimated Effort:** 1 week","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T16:24:05.944048+01:00","updated_at":"2025-11-09T16:24:05.944048+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-jxc","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:24:15.039784+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-jxc","depends_on_id":"wavesurfer.js-av8","type":"blocks","created_at":"2025-11-09T16:24:43.528713+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-kiz","content_hash":"494af7c14d6702a9ad37f65ca71c9388cbe92b4ed4d92b7f90a4bce83025c06d","title":"Update README and website documentation","description":"Update README.md and wavesurfer.xyz website with new documentation.\n\n## README Updates\n- Add reactive architecture mention\n- Update quick start example\n- Add link to migration guide\n- Update feature list\n- Add performance notes\n\n## Website Updates\n- New 'Reactive Architecture' page\n- Update API docs\n- Add migration guides\n- Update all examples\n- Add performance comparison\n\n## Documentation Site\n- API reference\n- Guides and tutorials\n- Migration path\n- Best practices\n- FAQ","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:59.485227+01:00","updated_at":"2025-11-09T14:39:14.4818+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-kiz","depends_on_id":"wavesurfer.js-0ib","type":"parent-child","created_at":"2025-11-09T14:28:59.524649+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-kiz","depends_on_id":"wavesurfer.js-bn7","type":"blocks","created_at":"2025-11-09T14:28:59.564636+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-kvb","content_hash":"8d168e959897cd9680c9dc8fd1adb0a40f7cae439c4de6c1da81f1eb7bef4dc5","title":"Prepare changelog and release notes","description":"Write comprehensive CHANGELOG.md and release announcement.\n\n## CHANGELOG.md\n```markdown\n# Changelog\n\n## [8.0.0] - YYYY-MM-DD\n\n### 🎉 Major Changes\n- Reactive architecture with signals and computed values\n- Declarative rendering with automatic updates\n- Functional core with pure functions\n- 20% reduction in code size\n\n### ✨ New Features\n- Reactive state management\n- Automatic subscription cleanup\n- Better TypeScript support\n- Improved performance\n\n### 💥 Breaking Changes\n- [List any breaking changes]\n- [Migration path for each]\n\n### 🐛 Bug Fixes\n- Fixed memory leaks\n- [Other fixes]\n\n### 📚 Documentation\n- Comprehensive reactive guides\n- Migration documentation\n- Updated all examples\n\n### ⚡ Performance\n- 5-10% faster rendering\n- Lower memory usage\n- Smaller bundle size\n```\n\n## Release Announcement\n- Blog post\n- Social media\n- GitHub release\n- npm release notes","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:59.619693+01:00","updated_at":"2025-11-09T14:39:14.525227+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-kvb","depends_on_id":"wavesurfer.js-0ib","type":"parent-child","created_at":"2025-11-09T14:28:59.660883+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-l1e","content_hash":"131e1f14b4026d7012fbbf44d08b1bf4eee6223761ec6f0babe9f20dc309ff6d","title":"Extract pure audio processing functions","description":"Extract pure audio processing functions from Player/WaveSurfer classes.\n\n## File: src/core/audio-processing.ts\n\n### extractPeaks(buffer, sampleRate, numberOfSamples): Float32Array[]\nPure function that extracts peak values from audio buffer\n```typescript\nexport function extractPeaks(\n  buffer: AudioBuffer,\n  sampleRate: number,\n  numberOfSamples: number\n): Float32Array[] {\n  const channels = []\n  for (let i = 0; i \u003c buffer.numberOfChannels; i++) {\n    channels.push(extractChannelPeaks(buffer.getChannelData(i), numberOfSamples))\n  }\n  return channels\n}\n\nfunction extractChannelPeaks(channelData: Float32Array, numberOfSamples: number): Float32Array {\n  const peaks = new Float32Array(numberOfSamples)\n  const blockSize = Math.floor(channelData.length / numberOfSamples)\n  \n  for (let i = 0; i \u003c numberOfSamples; i++) {\n    const start = i * blockSize\n    const end = start + blockSize\n    peaks[i] = findPeak(channelData.subarray(start, end))\n  }\n  \n  return peaks\n}\n\nfunction findPeak(samples: Float32Array): number {\n  let max = 0\n  for (let i = 0; i \u003c samples.length; i++) {\n    const abs = Math.abs(samples[i])\n    if (abs \u003e max) max = abs\n  }\n  return max\n}\n```\n\n### normalizeAudioData(peaks, maxPeak?): Float32Array[]\nPure function that normalizes peak values\n```typescript\nexport function normalizeAudioData(\n  peaks: Float32Array[],\n  maxPeak?: number\n): Float32Array[] {\n  const actualMax = maxPeak ?? Math.max(...peaks.flatMap(p =\u003e Array.from(p)))\n  if (actualMax === 0) return peaks\n  \n  return peaks.map(channel =\u003e {\n    const normalized = new Float32Array(channel.length)\n    for (let i = 0; i \u003c channel.length; i++) {\n      normalized[i] = channel[i] / actualMax\n    }\n    return normalized\n  })\n}\n```\n\n### calculateWaveformPoints(peaks, width, height, options): WaveformPoint[]\nPure function that calculates render points\n```typescript\nexport interface WaveformPoint {\n  x: number\n  y: number\n  height: number\n}\n\nexport function calculateWaveformPoints(\n  peaks: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    barWidth?: number\n    barGap?: number\n    barAlign?: 'top' | 'bottom'\n  }\n): WaveformPoint[] {\n  const points: WaveformPoint[] = []\n  // Pure calculation logic\n  return points\n}\n```\n\n### splitChannelData(buffer, options): ChannelRenderData[]\nPure function for multi-channel rendering data\n```typescript\nexport interface ChannelRenderData {\n  peaks: Float32Array\n  color: string\n  height: number\n  offset: number\n}\n\nexport function splitChannelData(\n  buffer: AudioBuffer,\n  options: WaveSurferOptions\n): ChannelRenderData[] {\n  // Pure calculation\n  return channels.map((peaks, i) =\u003e ({\n    peaks,\n    color: options.splitChannels?.[i]?.waveColor || options.waveColor,\n    height: calculateChannelHeight(i, buffer.numberOfChannels),\n    offset: calculateChannelOffset(i, buffer.numberOfChannels)\n  }))\n}\n```\n\n## Benefits\n- Easy to test (pure functions)\n- Can use in Web Workers\n- Reusable across components\n- No side effects\n- Predictable output\n\n## Testing\n- Test extractPeaks with various buffer sizes\n- Test normalizeAudioData edge cases (zero max, single value)\n- Test calculateWaveformPoints produces correct coordinates\n- Test splitChannelData for 1, 2, 4, 8 channels\n- Benchmark performance\n- Test with real audio files","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:25:55.889568+01:00","updated_at":"2025-11-09T14:37:45.964604+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-l1e","depends_on_id":"wavesurfer.js-rzj","type":"parent-child","created_at":"2025-11-09T14:25:55.92913+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-m15","content_hash":"6c9fd7c896cf91a1f85690771102ff8fe4eec6b48fdbdcf8260310644448d3f0","title":"Phase 5, Task 1: Complete test coverage for reactive system","description":"**Goal:** Achieve \u003e90% test coverage for all reactive components.\n\n**Areas to Cover:**\n- Signal system (subscribe, unsubscribe, effects)\n- Computed signals (caching, invalidation)\n- Event streams (all operators)\n- Render tree (diff/patch algorithm)\n- Canvas renderer (layering, batching)\n- All pure functions\n\n**Test Strategy:**\n- Unit tests for all reactive primitives\n- Integration tests for component interactions\n- E2E tests for user workflows\n- Property-based tests for pure functions\n- Memory leak tests\n\n**Dependencies:**\n- Blocks: All Phase 1-4 tasks\n\n**Success Criteria:**\n- \u003e90% code coverage\n- All edge cases covered\n- CI passes consistently\n- Performance tests included","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T16:48:37.74847+01:00","updated_at":"2025-11-09T16:48:50.248166+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-m15","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:48:50.287981+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-m2m","content_hash":"d21bbdbfcf37974c4da4ad4c46125e971fbf599d74aa264d419ce0b617aa7bc7","title":"Update event emission to be state-driven","description":"Update WaveSurfer event emission to be state-driven rather than manual.\n\n## Current Implementation\nManual event emission in callbacks:\n```typescript\nthis.onMediaEvent('play', () =\u003e {\n  this.emit('play')\n  this.timer.start()\n})\n\nthis.onMediaEvent('pause', () =\u003e {\n  this.emit('pause')\n  this.timer.stop()\n})\n\nthis.timer.on('tick', () =\u003e {\n  const currentTime = this.updateProgress()\n  this.emit('timeupdate', currentTime)\n  this.emit('audioprocess', currentTime)\n})\n```\n\n## New Implementation\nAutomatic event emission from state changes:\n```typescript\nclass WaveSurfer {\n  private setupEventEmission() {\n    // Play/pause events\n    this.state.isPlaying.subscribe(playing =\u003e {\n      this.emit(playing ? 'play' : 'pause')\n    })\n    \n    // Time update events\n    this.state.currentTime.subscribe(time =\u003e {\n      this.emit('timeupdate', time)\n      if (this.state.isPlaying.value) {\n        this.emit('audioprocess', time)\n      }\n    })\n    \n    // Seeking events\n    this.state.isSeeking.subscribe(seeking =\u003e {\n      if (seeking) {\n        this.emit('seeking', this.state.currentTime.value)\n      }\n    })\n    \n    // Ready event\n    this.state.isReady.subscribe(ready =\u003e {\n      if (ready) {\n        this.emit('ready', this.state.duration.value)\n      }\n    })\n    \n    // Zoom events\n    this.state.zoom.subscribe(zoom =\u003e {\n      this.emit('zoom', zoom)\n    })\n    \n    // Scroll events\n    this.state.scrollPosition.subscribe(pos =\u003e {\n      const duration = this.state.duration.value\n      const startTime = pos / this.scrollContainer.scrollWidth * duration\n      this.emit('scroll', startTime, /* ... */)\n    })\n  }\n}\n```\n\n## Benefits\n- Events always in sync with state\n- No manual emit() calls scattered around\n- Can't forget to emit event\n- Easy to add event listeners (just subscribe to state)\n- Clear event source (state changes)\n\n## Backward Compatibility\n- All existing events still fired\n- Same event data\n- Same timing (state changes when they did before)\n- Plugins don't need updates\n\n## Testing\n- Test each state change emits correct event\n- Test event data is correct\n- Test event timing matches old implementation\n- Test multiple subscribers work\n- Test old plugins still work","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:24:05.263279+01:00","updated_at":"2025-11-09T22:24:01.806137+01:00","closed_at":"2025-11-09T22:24:01.806137+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-m2m","depends_on_id":"wavesurfer.js-9yn","type":"parent-child","created_at":"2025-11-09T14:24:05.303534+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-m2m","depends_on_id":"wavesurfer.js-dky","type":"blocks","created_at":"2025-11-09T14:24:05.34091+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-m4m","content_hash":"c964fa771a5cf72dbdf298c57f58f89216c37b043cb17c6a95799c05f9eda486","title":"Create plugin adapter layer for backward compatibility","description":"Create adapter layer for backward compatibility with old-style plugins.\n\n## Plugin Adapter\nAllows old plugins to work with new reactive WaveSurfer:\n\n```typescript\n// src/adapters/plugin-adapter.ts\n\nexport function adaptLegacyPlugin\u003cT extends GenericPlugin\u003e(\n  plugin: T,\n  wavesurfer: WaveSurfer\n): T {\n  // Bridge reactive state to imperative API\n  const legacyAPI = {\n    getCurrentTime: () =\u003e wavesurfer.state.currentTime.value,\n    getDuration: () =\u003e wavesurfer.state.duration.value,\n    isPlaying: () =\u003e wavesurfer.state.isPlaying.value,\n    // ... all other methods\n  }\n  \n  // Wrap plugin to use legacy API\n  return new Proxy(plugin, {\n    get(target, prop) {\n      if (prop === 'wavesurfer') {\n        return legacyAPI\n      }\n      return target[prop]\n    }\n  })\n}\n```\n\n## Usage\n```typescript\n// Old plugin works automatically\nconst oldPlugin = OldStylePlugin.create()\nwavesurfer.registerPlugin(adaptLegacyPlugin(oldPlugin, wavesurfer))\n```\n\n## Testing\n- Test old plugins work with adapter\n- Test all methods proxy correctly\n- Test events still fire\n- Test no performance degradation","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:25:57.010788+01:00","updated_at":"2025-11-09T14:39:14.065273+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-m4m","depends_on_id":"wavesurfer.js-rzj","type":"parent-child","created_at":"2025-11-09T14:25:57.05165+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-m4m","depends_on_id":"wavesurfer.js-jwq","type":"blocks","created_at":"2025-11-09T14:25:57.092266+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-mec","content_hash":"3a17e64708c725b16af1f2358af0159a0df69fcf0dc3fee187865d4bff56fb31","title":"Phase 2, Task 6: Convert Markers plugin rendering to declarative","description":"**NOTE:** This task was closed because there is no separate Markers plugin. Markers are simply zero-width regions (where end = start or no end is specified). The Regions plugin already handles this case using DOM rendering.\n\n**Original Goal:** Make Markers plugin rendering declarative.\n\n**Resolution:** Regions plugin (Task 5) already implements reactive DOM-based rendering for all region types, including markers. Zero-width regions are rendered as vertical lines and work identically to what would have been markers.\n\n**Implementation in Regions plugin:**\n- Regions use DOM elements (`\u003cdiv\u003e`) for rendering\n- Reactive updates via signals and effects\n- Zero-width regions (markers) automatically render as thin vertical lines\n- All region interactions work the same way\n\n**Why no canvas rendering:**\n- Only waveform and spectrogram should be rendered on canvas\n- All other UI elements (regions, cursor, timeline, etc.) use DOM\n- DOM provides better interactivity and accessibility\n- Regions plugin already uses reactive DOM rendering (completed in Task 5)\n\n**Success Criteria:**\n✅ Regions (including markers) render with DOM\n✅ Reactive updates work correctly\n✅ Zero-width regions work as markers\n✅ No separate markers plugin needed","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:40:56.359014+01:00","updated_at":"2025-11-09T19:56:10.999927+01:00","closed_at":"2025-11-09T18:49:34.170826+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-mec","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:41:10.865693+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-mec","depends_on_id":"wavesurfer.js-uas","type":"blocks","created_at":"2025-11-09T16:41:10.90477+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-ms3","content_hash":"32693497dbbec1621482d063d5bc549ee230b44967c18f45b8aead5d0adf6de2","title":"Phase 3, Task 2: Convert click events to streams","description":"**Goal:** Convert imperative click event handling to reactive event streams.\n\n**Current Code:**\n```typescript\ncanvas.addEventListener('click', (e) =\u003e {\n  const x = e.offsetX\n  const time = this.pixelToTime(x)\n  this.seekTo(time)\n  this.emit('click', time)\n})\n```\n\n**New Code:**\n```typescript\n// Create click stream\nprivate setupClickStream() {\n  const clicks = fromDOMEvent(this.canvas, 'click')\n    .map(e =\u003e ({\n      x: e.offsetX,\n      y: e.offsetY,\n      time: this.pixelToTime(e.offsetX)\n    }))\n  \n  // Handle clicks declaratively\n  clicks.subscribe(({ time }) =\u003e {\n    this.timeSignal.value = time\n  })\n  \n  // Expose as public stream\n  this.clicks$ = clicks\n}\n\n// Plugins/users can subscribe\nwavesurfer.clicks$.subscribe(({ time }) =\u003e {\n  console.log('Clicked at', time)\n})\n```\n\n**Benefits:**\n- Declarative click handling\n- Easy to compose (e.g., double-click detection)\n- Testable without DOM\n- Plugins can subscribe to clicks\n\n**Dependencies:**\n- Blocks: wavesurfer.js-ix6 (needs EventStream)\n\n**Success Criteria:**\n- Click events work identically\n- All click-related tests pass\n- Public API for click stream\n- Easy to detect double-clicks, long-presses","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:44:26.993724+01:00","updated_at":"2025-11-09T21:30:14.054598+01:00","closed_at":"2025-11-09T21:30:14.054598+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-ms3","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:44:38.590282+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-ms3","depends_on_id":"wavesurfer.js-ix6","type":"blocks","created_at":"2025-11-09T16:44:38.628506+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-n5k","content_hash":"e3486e56f12be1bf2bae05dbdf62fd0c4c3fe185442c80880f35c37e1422ba17","title":"Phase 2, Task 4: Convert cursor rendering to declarative","description":"**Goal:** Make cursor/playhead rendering declarative and reactive to time changes.\n\n**Current Code:**\n```typescript\nprivate drawCursor() {\n  const { ctx, width, height } = this.canvasWrapper.getContext()\n  const x = this.getCurrentTime() / this.getDuration() * width\n  \n  ctx.fillStyle = this.options.cursorColor\n  ctx.fillRect(x - this.options.cursorWidth / 2, 0, this.options.cursorWidth, height)\n}\n```\n\n**New Code:**\n```typescript\nprivate buildCursorTree(): RenderNode | null {\n  \n  const { width, height } = this.canvasWrapper.getContext()\n  const progress = this.currentTime / this.duration\n  const x = progress * width\n  \n  return {\n    type: 'rect',\n    key: 'cursor',\n    props: {\n      x: x - this.options.cursorWidth / 2,\n      y: 0,\n      width: this.options.cursorWidth,\n      height,\n      fill: this.options.cursorColor\n    }\n  }\n}\n\n// Integrate with reactive time\nprivate setupCursorRendering() {\n  this.timeSignal.subscribe(time =\u003e {\n    this.currentTime = time\n    this.render() // Will rebuild tree and diff\n  })\n}\n```\n\n**Benefits:**\n- Cursor updates don't trigger full waveform redraw\n- Smooth animations via requestAnimationFrame batching\n- Easy to add cursor effects (glow, shadow) declaratively\n\n**Dependencies:**\n- Blocks: wavesurfer.js-uas (needs RenderTree)\n\n**Success Criteria:**\n- Cursor position updates smoothly during playback\n- No unnecessary waveform redraws\n- Works with all cursor options\n- 60fps cursor animation","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:40:17.025178+01:00","updated_at":"2025-11-09T18:15:14.079838+01:00","closed_at":"2025-11-09T18:15:14.079838+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-n5k","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:40:28.010805+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-n5k","depends_on_id":"wavesurfer.js-uas","type":"blocks","created_at":"2025-11-09T16:40:28.048778+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-n7g","content_hash":"b42a3f0962c0cb19b4c01dc8c925a56e4fe4dad7b31e762dda3ec3be33ca2f73","title":"Phase 5, Task 8: Final code cleanup and linting","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-09T16:48:38.111083+01:00","updated_at":"2025-11-09T16:48:38.111083+01:00","source_repo":"."}
{"id":"wavesurfer.js-o9l","content_hash":"fdf9d7d631f73f85450beb8d5772dea5626e989ee1b8e99bcd12311be26955ef","title":"Migrate scroll handling to reactive pattern","description":"Migrate scroll handling to reactive pattern.\n\n## Current Implementation\n```typescript\n// Manual scroll listener\nthis.scrollContainer.addEventListener('scroll', () =\u003e {\n  const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer\n  const { startX, endX } = utils.calculateScrollPercentages({\n    scrollLeft, scrollWidth, clientWidth\n  })\n  this.emit('scroll', startX, endX, scrollLeft, scrollLeft + clientWidth)\n})\n```\n\n## New Implementation\nFile: src/interactions/scroll-handler.ts\n\n```typescript\nclass ScrollHandler {\n  private scrollPosition = signal(0)\n  \n  constructor(\n    private scrollContainer: HTMLElement,\n    private state: WaveSurferState\n  ) {\n    this.setupScrollStream()\n  }\n  \n  private setupScrollStream() {\n    // Convert scroll events to stream\n    const scrollStream = fromEvent(this.scrollContainer, 'scroll')\n    \n    // Map to position\n    const position = map(scrollStream, () =\u003e {\n      return this.scrollContainer.scrollLeft\n    })\n    \n    // Update state\n    effect(\n      () =\u003e {\n        const pos = position.value\n        if (pos !== null) {\n          this.state.scrollPosition.set(pos)\n        }\n      },\n      [position]\n    )\n    \n    // Calculate visible percentages (computed)\n    const visiblePercentages = computed(\n      () =\u003e {\n        const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer\n        return utils.calculateScrollPercentages({\n          scrollLeft, scrollWidth, clientWidth\n        })\n      },\n      [this.state.scrollPosition]\n    )\n    \n    // Emit scroll events (automatic)\n    effect(\n      () =\u003e {\n        const { startX, endX } = visiblePercentages.value\n        const scrollLeft = this.state.scrollPosition.value\n        this.emit('scroll', startX, endX, scrollLeft, scrollLeft + clientWidth)\n      },\n      [visiblePercentages]\n    )\n  }\n}\n```\n\n## Benefits\n- Scroll position is observable state\n- Can react to scroll from anywhere\n- Computed visible percentages\n- Automatic event emission\n- Easy to add scroll-based features\n\n## Testing\n- Test scroll updates position state\n- Test visible percentages calculated correctly\n- Test scroll events emitted\n- Test cleanup removes listener\n- Test programmatic scroll updates state","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:24:05.037562+01:00","updated_at":"2025-11-09T22:20:11.245812+01:00","closed_at":"2025-11-09T22:20:11.245812+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-o9l","depends_on_id":"wavesurfer.js-9yn","type":"parent-child","created_at":"2025-11-09T14:24:05.076527+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-oc5","content_hash":"6f5bacde7c28fd469f5213c49676f6e3c8baef40974d419fdbdb61447822841c","title":"Phase 3, Task 10: Add event stream testing utilities","description":"**Goal:** Testing utilities for event streams.\n\n**Implementation:**\n```typescript\n// src/events/__tests__/test-utils.ts\n\nexport class TestEventStream\u003cT\u003e {\n  private emissions: T[] = []\n  private stream: EventStream\u003cT\u003e\n  \n  constructor(stream: EventStream\u003cT\u003e) {\n    this.stream = stream\n    stream.subscribe(value =\u003e this.emissions.push(value))\n  }\n  \n  expect(count: number) {\n    expect(this.emissions).toHaveLength(count)\n    return this\n  }\n  \n  expectLast(value: T) {\n    expect(this.emissions[this.emissions.length - 1]).toEqual(value)\n    return this\n  }\n  \n  expectAll(values: T[]) {\n    expect(this.emissions).toEqual(values)\n    return this\n  }\n  \n  reset() {\n    this.emissions = []\n  }\n}\n\n// Mock event emitter\nexport class MockEventTarget {\n  private listeners: Map\u003cstring, Set\u003cFunction\u003e\u003e = new Map()\n  \n  addEventListener(event: string, handler: Function) {\n      this.listeners.set(event, new Set())\n    }\n  }\n  \n  removeEventListener(event: string, handler: Function) {\n    this.listeners.get(event)?.delete(handler)\n  }\n  \n  // Test helper\n  emit(event: string, data: any) {\n    this.listeners.get(event)?.forEach(h =\u003e h(data))\n  }\n}\n\n// Time utilities\nexport class VirtualTime {\n  private now = 0\n  \n  advance(ms: number) {\n    this.now += ms\n    return this.now\n  }\n  \n  runTimers() {\n    // Flush all pending timers\n    jest.runAllTimers()\n  }\n}\n```\n\n**Example Tests:**\n```typescript\ndescribe('EventStream', () =\u003e {\n  it('throttles events', () =\u003e {\n    const time = new VirtualTime()\n    const mockEl = new MockEventTarget()\n    const stream = fromDOMEvent(mockEl, 'click').throttle(100)\n    const test = new TestEventStream(stream)\n    \n    mockEl.emit('click', {})\n    mockEl.emit('click', {})\n    time.advance(50)\n    mockEl.emit('click', {})\n    time.advance(60)\n    mockEl.emit('click', {})\n    \n    test.expect(2) // Only 2 events emitted due to throttle\n  })\n  \n  it('maps values', () =\u003e {\n    const mockEl = new MockEventTarget()\n    const stream = fromDOMEvent(mockEl, 'click')\n      .map(e =\u003e e.x)\n    const test = new TestEventStream(stream)\n    \n    mockEl.emit('click', { x: 10 })\n    mockEl.emit('click', { x: 20 })\n    \n    test.expectAll([10, 20])\n  })\n})\n```\n\n**Dependencies:**\n- Blocks: wavesurfer.js-ix6\n\n**Success Criteria:**\n- Complete test utilities\n- Example tests\n- Works with Jest\n- Documentation","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-09T16:45:44.083361+01:00","updated_at":"2025-11-09T16:47:08.852784+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-oc5","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:47:08.891942+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-oc5","depends_on_id":"wavesurfer.js-ix6","type":"blocks","created_at":"2025-11-09T16:47:08.930492+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-ofj","content_hash":"b7fa8cce82f4feccfebeb7f331da6bf74982df34912bc5f7660fa81523d6b7a1","title":"Write unit tests for reactive primitives","description":"Comprehensive test coverage for all reactive primitives.\n\n## Test Files\n- src/reactive/__tests__/store.test.ts\n- src/reactive/__tests__/event-streams.test.ts\n- src/state/__tests__/wavesurfer-state.test.ts\n\n## Coverage Requirements\n- \u003e95% line coverage for reactive code\n- 100% branch coverage for core primitives\n- Edge cases tested (null, undefined, errors)\n- Performance tests for large subscriber lists\n- Memory leak tests (subscriptions cleanup)\n\n## Test Categories\n\n### Signal Tests\n- Basic get/set/update\n- Subscriber notifications\n- Multiple subscribers\n- No notification if unchanged\n- Unsubscribe works\n- Memory cleanup\n\n### Computed Tests\n- Recalculates on dependency change\n- Caches results\n- Multiple dependencies\n- Nested computed values\n- Circular dependency detection\n\n### Effect Tests\n- Runs on dependency change\n- Cleanup functions called\n- Re-run cleanup before new run\n- Unsubscribe stops execution\n- Initial run happens\n- Multiple dependencies\n\n### Event Stream Tests\n- fromEvent converts events\n- map transforms correctly\n- filter removes values\n- debounce delays updates\n- throttle limits frequency\n- Cleanup removes listeners\n- Stream composition\n\n### State Tests\n- All signals update\n- All computed values work\n- Actions modify state\n- No cross-instance pollution\n- TypeScript types correct\n\n## Tools\n- Jest for unit tests\n- @testing-library/dom for DOM testing\n- Mock timers for debounce/throttle\n- Memory profiling for leak detection\n\n## Run Tests\n```bash\nyarn test:unit src/reactive\nyarn test:unit src/state\n```","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:05.182868+01:00","updated_at":"2025-11-09T15:09:12.445724+01:00","closed_at":"2025-11-09T15:09:12.445724+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-ofj","depends_on_id":"wavesurfer.js-93k","type":"parent-child","created_at":"2025-11-09T14:23:05.222479+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-ofj","depends_on_id":"wavesurfer.js-61x","type":"blocks","created_at":"2025-11-09T14:23:05.260146+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-ofj","depends_on_id":"wavesurfer.js-32u","type":"blocks","created_at":"2025-11-09T14:23:05.298221+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-ofj","depends_on_id":"wavesurfer.js-trx","type":"blocks","created_at":"2025-11-09T14:23:05.336405+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-pu6","content_hash":"42d821c81b9629ad63ee886ecf4264c780498c21c2106f4fc322732dd24515a5","title":"Phase 2, Task 11: Add render tree testing utilities","description":"**Goal:** Create testing utilities for verifying render trees and declarative rendering.\n\n**Implementation:**\n```typescript\n// src/renderer/__tests__/test-utils.ts\n\nexport class RenderTreeMatcher {\n  // Assert tree structure\n  static expectTree(tree: RenderTree) {\n    return {\n      toHaveNode(key: string) {\n        const node = tree.findNode(key)\n        expect(node).toBeDefined()\n        return this\n      },\n      \n      toHaveNodeWithProps(key: string, props: Partial\u003cRenderProps\u003e) {\n        const node = tree.findNode(key)\n        expect(node).toBeDefined()\n        return this\n      },\n      \n      toHaveChildCount(count: number) {\n        expect(tree.root.children).toHaveLength(count)\n        return this\n      },\n      \n      toMatchSnapshot() {\n        expect(tree.toJSON()).toMatchSnapshot()\n        return this\n      }\n    }\n  }\n}\n\n// Mock canvas for testing\nexport class MockCanvasContext {\n  calls: Array\u003c{ method: string; args: any[] }\u003e = []\n  \n  // Record all canvas operations\n  fillRect(...args: any[]) {\n    this.calls.push({ method: 'fillRect', args })\n  }\n  \n  strokeRect(...args: any[]) {\n    this.calls.push({ method: 'strokeRect', args })\n  }\n  \n  // ... other canvas methods\n  \n  // Assertions\n  expectCalled(method: string, times?: number) {\n    const calls = this.calls.filter(c =\u003e c.method === method)\n    if (times !== undefined) {\n      expect(calls).toHaveLength(times)\n    } else {\n      expect(calls.length).toBeGreaterThan(0)\n    }\n  }\n  \n  expectNotCalled(method: string) {\n    const calls = this.calls.filter(c =\u003e c.method === method)\n    expect(calls).toHaveLength(0)\n  }\n  \n  reset() {\n    this.calls = []\n  }\n}\n\n// Render tree builder for tests\nexport class TestRenderTreeBuilder {\n  static waveform(props: Partial\u003cRenderProps\u003e = {}): RenderNode {\n    return {\n      type: 'path',\n      key: 'waveform',\n      props: {\n        fill: '#999',\n        ...props\n      }\n    }\n  }\n  \n  static region(id: string, props: Partial\u003cRenderProps\u003e = {}): RenderNode {\n    return {\n      type: 'rect',\n      key: `region-${id}`,\n      props: {\n        fill: 'rgba(0,0,0,0.1)',\n        ...props\n      }\n    }\n  }\n  \n  static cursor(x: number): RenderNode {\n    return {\n      type: 'rect',\n      key: 'cursor',\n      props: {\n        x,\n        y: 0,\n        width: 2,\n        height: 100,\n        fill: '#000'\n      }\n    }\n  }\n}\n```\n\n**Example Tests:**\n```typescript\ndescribe('Waveform Rendering', () =\u003e {\n  it('builds correct render tree', () =\u003e {\n    const renderer = new Renderer(options)\n    const tree = renderer.buildWaveformTree(peaks)\n    \n    RenderTreeMatcher.expectTree(tree)\n      .toHaveNode('waveform')\n      .toHaveNodeWithProps('waveform', {\n        fill: '#999'\n      })\n      .toMatchSnapshot()\n  })\n  \n  it('only redraws changed parts', () =\u003e {\n    const ctx = new MockCanvasContext()\n    const renderer = new CanvasRenderer()\n    \n    const tree1 = new RenderTree(TestRenderTreeBuilder.waveform())\n    renderer.render(tree1, ctx as any)\n    \n    const callCount1 = ctx.calls.length\n    ctx.reset()\n    \n    // Render same tree - should skip\n    renderer.render(tree1, ctx as any)\n    expect(ctx.calls.length).toBe(0)\n    \n    // Render different tree - should redraw\n    const tree2 = new RenderTree(TestRenderTreeBuilder.waveform({ fill: '#000' }))\n    renderer.render(tree2, ctx as any)\n    expect(ctx.calls.length).toBeGreaterThan(0)\n  })\n})\n```\n\n**Benefits:**\n- Easier to test rendering logic\n- Verify trees without rendering to canvas\n- Snapshot testing for render trees\n- Mock canvas operations\n- Better test coverage\n\n**Dependencies:**\n- Blocks: wavesurfer.js-uas (needs RenderTree implementation)\n\n**Success Criteria:**\n- Complete test utilities for RenderTree\n- Mock canvas context works\n- Example tests demonstrate usage\n- Documentation for test utils\n- Tests for test utils themselves","notes":"COMPLETED: Added comprehensive testing utilities for RenderTree. Created src/renderer/test-utils.ts with RenderTreeMatcher, MockCanvasContext, and TestTreeBuilder. All 42 tests passing. Utilities enable easy testing of declarative rendering, tree structure assertions, canvas operation tracking, and snapshot testing.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-09T16:42:46.095917+01:00","updated_at":"2025-11-09T20:57:52.835993+01:00","closed_at":"2025-11-09T20:57:52.339139+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-pu6","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:43:09.120706+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-pu6","depends_on_id":"wavesurfer.js-uas","type":"blocks","created_at":"2025-11-09T16:43:09.158845+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-pyo","content_hash":"239790e9767875fc5df07d12527955ec5aa85b8ab4cbc91e680f0fec636d213e","title":"Remove HoverManager - violates architecture (canvas should not be interactive)","description":"**Goal:** Remove HoverManager and related hover infrastructure from the declarative rendering system.\n\n**Rationale:**\nHoverManager was designed to make canvas elements interactive, but this violates the core rendering architecture:\n- **Canvas rendering:** Only waveform and spectrogram (non-interactive backgrounds)\n- **DOM rendering:** All interactive elements (regions, cursor, timeline, hover, markers, etc.)\n\nThe existing Hover.ts plugin already implements hover correctly using DOM elements. HoverManager adds complexity for no benefit and is never actually used in production code (only in tests).\n\n**Evidence:**\n- `enableHover` option exists in CanvasRenderer but is never set to `true` anywhere in production code\n- Hover.ts plugin uses DOM elements (correct approach)\n- Waveform/spectrogram don't need hover effects (they're static backgrounds)\n- All interactive elements already use DOM (regions, markers, cursor, timeline)\n\n**Files to Remove:**\n```bash\nrm src/renderer/HoverManager.ts\nrm src/renderer/__tests__/HoverManager.test.ts\nrm src/renderer/__tests__/CanvasRenderer-hover.test.ts\n```\n\n**Code to Update:**\n\n1. **src/renderer/RenderTree.ts:**\n   - Remove `HoverConfig` interface\n   - Remove `hover?` property from `RenderNode`\n   - Remove `hitBounds?` property from `RenderNode`\n   - Remove `hitTest()` method and `hitTestNode()` helper\n\n2. **src/renderer/CanvasRenderer.ts:**\n   - Remove `enableHover` option from `CanvasRendererOptions`\n   - Remove `hoverManager` property\n   - Remove `HoverManager` import\n   - Remove hover-related initialization in constructor\n   - Remove `getHoverManager()` method\n   - Simplify `renderNode()` - remove `getMergedProps()` call, use `node.props` directly\n\n**Benefits:**\n- ✅ Aligns with architecture (canvas = non-interactive)\n- ✅ Removes unused code (~200 LOC + tests)\n- ✅ Simplifies RenderTree and CanvasRenderer\n- ✅ Removes complexity (hit testing, hover props merging)\n- ✅ Hover.ts plugin continues to work (uses DOM, not canvas)\n\n**Testing:**\n- Run existing tests (should still pass)\n- Verify Hover.ts plugin still works\n- Ensure waveform/spectrogram rendering unaffected\n\n**Success Criteria:**\n- HoverManager completely removed\n- All tests passing\n- Hover.ts plugin works correctly\n- No references to hover in canvas rendering code\n- Architecture principles upheld (canvas = non-interactive)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-09T20:51:41.059856+01:00","updated_at":"2025-11-09T21:04:37.292087+01:00","closed_at":"2025-11-09T21:04:37.292087+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-pyo","depends_on_id":"wavesurfer.js-wpg","type":"discovered-from","created_at":"2025-11-09T20:51:48.394316+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-q4l","content_hash":"84ae662792630b66e5bfaf5faf5d89f2e392bb378693db3db999e0b632f749e5","title":"Phase 3, Task 7: Convert resize events to streams","description":"**Goal:** Responsive resize handling with debounced streams.\n\n**Implementation:**\n```typescript\nprivate setupResizeStream() {\n  const resizes = fromDOMEvent(window, 'resize')\n    .debounce(150) // Debounce rapid resize events\n    .map(() =\u003e ({\n      width: this.wrapper.clientWidth,\n      height: this.wrapper.clientHeight\n    }))\n  \n  resizes.subscribe(({ width, height }) =\u003e {\n    this.widthSignal.value = width\n    this.heightSignal.value = height\n    this.updateCanvasSize()\n  })\n  \n  // ResizeObserver for container changes\n  const observer = new ResizeObserver(entries =\u003e {\n    for (const entry of entries) {\n      this.widthSignal.value = entry.contentRect.width\n      this.heightSignal.value = entry.contentRect.height\n    }\n  })\n  \n  observer.observe(this.wrapper)\n}\n```\n\n**Dependencies:**\n- Blocks: wavesurfer.js-ix6\n\n**Success Criteria:**\n- Smooth resize handling\n- No resize jank\n- Works with flex/grid layouts","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:45:21.970139+01:00","updated_at":"2025-11-09T21:42:52.395572+01:00","closed_at":"2025-11-09T21:42:52.395572+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-q4l","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:46:26.617619+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-q4l","depends_on_id":"wavesurfer.js-ix6","type":"blocks","created_at":"2025-11-09T16:46:26.657791+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-qsq","content_hash":"d2c24f4ce162724fe329cf003aacb5b8ab66e19954a0201e43576899e1690964","title":"Set up CI/CD for reactive branch","description":"Set up CI/CD pipeline for reactive refactoring branch.\n\n## GitHub Actions Workflows\n\n### .github/workflows/reactive-ci.yml\n```yaml\nname: Reactive Branch CI\n\non:\n  push:\n    branches: [reactive/**]\n  pull_request:\n    branches: [reactive/**]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      - run: yarn install\n      - run: yarn lint\n      - run: yarn test:unit\n      - run: yarn build\n      \n  coverage:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n      - run: yarn install\n      - run: yarn test:unit --coverage\n      - uses: codecov/codecov-action@v3\n        \n  performance:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n      - run: yarn install\n      - run: yarn build\n      - run: node scripts/benchmark.js\n      - name: Compare with main\n        run: node scripts/compare-performance.js\n        \n  size:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n      - run: yarn install\n      - run: yarn build\n      - uses: andresz1/size-limit-action@v1\n```\n\n## Branch Protection\n- Require CI pass before merge\n- Require code review\n- Require up-to-date branch\n\n## Notifications\n- Slack on failure\n- PR comments with metrics","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:29:16.004909+01:00","updated_at":"2025-11-09T14:40:56.876357+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-qsq","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T14:29:16.043857+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-rzj","content_hash":"7eeea8d2aa55ba65616f4df2f2fa4ea9cfe7542f983326723ba80660aefc5b5e","title":"Phase 4: Separate Pure Logic from Side Effects","description":"Separate pure logic from side effects using Functional Core, Imperative Shell pattern.\n\n## Goals\n- Extract pure functions for audio processing\n- Extract pure functions for calculations\n- Refactor WaveSurfer to thin shell around reactive core\n- Migrate all official plugins to reactive patterns\n- Create adapter for old-style plugins\n\n## Deliverables\n- src/core/audio-processing.ts (pure functions)\n- src/core/calculations.ts (pure functions)\n- WaveSurfer as thin shell\n- All plugins migrated\n- Plugin adapter layer\n\n## Estimated Time\n4-5 weeks\n\n## Pattern: Functional Core, Imperative Shell\nCORE (Pure): Functions with no side effects, easy to test\nSHELL (Imperative): Thin layer that calls pure functions and handles I/O\n\n## Success Criteria\n- \u003e50% of code is pure functions\n- WaveSurfer class \u003c500 LOC\n- All plugins use reactive state\n- Old plugins work via adapter\n- Test coverage \u003e90%","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:25:55.703307+01:00","updated_at":"2025-11-09T14:37:45.925991+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-rzj","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T14:25:55.75072+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-rzj","depends_on_id":"wavesurfer.js-gmg","type":"blocks","created_at":"2025-11-09T14:25:55.792555+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-rzj","depends_on_id":"wavesurfer.js-9yn","type":"blocks","created_at":"2025-11-09T14:25:55.833861+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-rzj","depends_on_id":"wavesurfer.js-0m3","type":"blocks","created_at":"2025-11-09T14:29:15.950316+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-s89","content_hash":"5132bebf8a96278ec175c8a08510d6edf83d5b80cd03d4b1528b6b9f71c92d2e","title":"Phase 2, Task 2: Convert Renderer drawWaveform to declarative","description":"**Goal:** Refactor `Renderer.drawWaveform()` to build a RenderTree instead of directly manipulating canvas.\n\n**Current Code (imperative):**\n```typescript\nprivate drawWaveform() {\n  const { ctx, width, height } = this.canvasWrapper.getContext()\n  ctx.clearRect(0, 0, width, height)\n  \n  // Imperative drawing\n  ctx.fillStyle = this.options.waveColor\n  ctx.beginPath()\n  // ... direct canvas manipulation\n  ctx.fill()\n}\n```\n\n**New Code (declarative):**\n```typescript\nprivate buildWaveformTree(peaks: AudioPeaks): RenderNode {\n  const { width, height } = this.canvasWrapper.getContext()\n  \n  return {\n    type: 'group',\n    key: 'waveform',\n    children: [\n      {\n        type: 'path',\n        key: 'waveform-path',\n        props: {\n          d: this.buildWaveformPath(peaks, width, height),\n          fill: this.options.waveColor,\n          opacity: 1\n        }\n      },\n      this.options.progressColor \u0026\u0026 {\n        type: 'path',\n        key: 'progress-path',\n        props: {\n          d: this.buildWaveformPath(peaks, width * this.progress, height),\n          fill: this.options.progressColor,\n          opacity: 1\n        }\n      }\n    ].filter(Boolean)\n  }\n}\n\nprivate drawWaveform() {\n  const peaks = this.getPeaks()\n  const tree = new RenderTree(this.buildWaveformTree(peaks))\n  this.renderer.render(tree, this.canvasWrapper.getContext().ctx)\n}\n```\n\n**Dependencies:**\n- Blocks: wavesurfer.js-uas (needs RenderTree)\n\n**Success Criteria:**\n- Waveform rendering produces identical visual output\n- Code is more testable (can test tree building separately)\n- Progress updates don't require full redraw\n- All existing waveform tests pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:39:44.060877+01:00","updated_at":"2025-11-09T18:06:42.802694+01:00","closed_at":"2025-11-09T18:06:42.802694+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-s89","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:39:56.357607+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-s89","depends_on_id":"wavesurfer.js-uas","type":"blocks","created_at":"2025-11-09T16:39:56.395925+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-se8","content_hash":"3820846efe4f0d3eaa71b372624d713e4e23d12065192e5c77b83f9e2d714011","title":"Phase 4, Task 7: Extract pure time/pixel conversion functions","description":"**Goal:** Pure time/pixel conversions.\n\n**Implementation:**\n```typescript\nexport const TimePixelConverter = {\n  toPixel: (time: number, params: ConverterParams) =\u003e number,\n  toTime: (pixel: number, params: ConverterParams) =\u003e number,\n  getVisibleRange: (params: ConverterParams) =\u003e { start: number, end: number }\n}\n```\n\n**Success Criteria:**\n- Pure functions\n- Fully tested\n- Used everywhere","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:47:21.368323+01:00","updated_at":"2025-11-09T21:59:29.802961+01:00","closed_at":"2025-11-09T21:59:29.802961+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-se8","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:48:14.162574+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-se8","depends_on_id":"wavesurfer.js-cq2","type":"blocks","created_at":"2025-11-09T16:48:14.204897+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-trx","content_hash":"9111f7fc30fc9ce1960c41dd6dae883f885003e5163956c2da8eb42e84701792","title":"Create centralized WaveSurferState","description":"Create single source of truth for all WaveSurfer state using signals.\n\n## Implementation\nFile: src/state/wavesurfer-state.ts\n\n### State Properties (Signals)\n- currentTime: Signal\u003cnumber\u003e\n- duration: Signal\u003cnumber\u003e\n- isPlaying: Signal\u003cboolean\u003e\n- isSeeking: Signal\u003cboolean\u003e\n- volume: Signal\u003cnumber\u003e\n- playbackRate: Signal\u003cnumber\u003e\n- audioBuffer: Signal\u003cAudioBuffer | null\u003e\n- peaks: Signal\u003cArray\u003cFloat32Array\u003e | null\u003e\n- url: Signal\u003cstring\u003e\n- zoom: Signal\u003cnumber\u003e\n- scrollPosition: Signal\u003cnumber\u003e\n\n### Computed State (Derived)\n- canPlay: computed(() =\u003e audioBuffer.value !== null)\n- isReady: computed(() =\u003e canPlay \u0026\u0026 duration \u003e 0)\n- progressPercent: computed(() =\u003e currentTime / duration)\n\n### Actions\n- setCurrentTime(time: number)\n- setDuration(duration: number)\n- setPlaying(playing: boolean)\n- setSeeking(seeking: boolean)\n- setVolume(volume: number)\n- setPlaybackRate(rate: number)\n- setAudioBuffer(buffer: AudioBuffer | null)\n- setPeaks(peaks: Array\u003cFloat32Array\u003e | null)\n- setUrl(url: string)\n- setZoom(zoom: number)\n- setScrollPosition(pos: number)\n\n### Factory Function\n```typescript\nfunction createWaveSurferState(): {\n  state: WaveSurferState\n  actions: WaveSurferActions\n}\n```\n\n## Testing\n- Test all signals update correctly\n- Test computed values recalculate\n- Test actions update state properly\n- Test computed dependencies work\n- Test no circular dependencies\n- Test state isolation (multiple instances)\n\n## Integration\n- Does NOT replace existing code yet\n- Can be used alongside current implementation\n- Bridge state updates manually for now\n- Full integration happens in Phase 4","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:05.052871+01:00","updated_at":"2025-11-09T15:08:15.030885+01:00","closed_at":"2025-11-09T15:08:15.030885+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-trx","depends_on_id":"wavesurfer.js-93k","type":"parent-child","created_at":"2025-11-09T14:23:05.090834+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-trx","depends_on_id":"wavesurfer.js-61x","type":"blocks","created_at":"2025-11-09T14:23:05.128785+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-tzi","content_hash":"afc5e3cafa469974942434ff46c36b442c4a2b456c33bcc3fb159cc82a6641f5","title":"Migrate Minimap plugin to reactive pattern","description":"Migrate Minimap plugin to reactive pattern. Auto-sync scroll with main waveform.","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:25:56.658048+01:00","updated_at":"2025-11-09T14:39:13.982779+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-tzi","depends_on_id":"wavesurfer.js-rzj","type":"parent-child","created_at":"2025-11-09T14:25:56.699682+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-tzi","depends_on_id":"wavesurfer.js-jwq","type":"blocks","created_at":"2025-11-09T14:25:56.740093+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-u2k","content_hash":"5fea09a843c331d139e5b2601964dcd1e83cb973f9222be8d24d19a004ddf9d7","title":"Phase 4, Task 5: Extract pure color manipulation functions","description":"**Goal:** Pure color manipulation.\n\n**Implementation:**\n```typescript\nexport function parseColor(color: string): RGBA {\n  // Parse CSS color to RGBA\n}\n\nexport function interpolateColor(from: RGBA, to: RGBA, t: number): RGBA {\n  return {\n    r: from.r + (to.r - from.r) * t,\n    g: from.g + (to.g - from.g) * t,\n    b: from.b + (to.b - from.b) * t,\n    a: from.a + (to.a - from.a) * t\n  }\n}\n\nexport function rgbaToString(rgba: RGBA): string {\n  return `rgba(${rgba.r},${rgba.g},${rgba.b},${rgba.a})`\n}\n```\n\n**Success Criteria:**\n- All color ops pure\n- Color gradients\n- Tests","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-09T16:47:21.265856+01:00","updated_at":"2025-11-09T22:13:51.952608+01:00","closed_at":"2025-11-09T22:13:51.952608+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-u2k","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:48:14.007248+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-u6q","content_hash":"168350058a2350796758bd2f9879e5ecd8d5b1927457d2a64044a07926d853b8","title":"Phase 5, Task 6: Update API documentation","description":"**Goal:** Update all API documentation for reactive architecture.\n\n**Documentation Updates:**\n- API reference (all methods/properties)\n- Reactive concepts guide\n- Signal API docs\n- Event stream API docs\n- Plugin development guide\n- TypeScript definitions\n- Code examples\n- Tutorials\n\n**New Sections:**\n- Reactive Programming Primer\n- Signal System Guide\n- Event Streams Guide\n- Pure Functions Guide\n- Performance Optimization\n- Debugging Reactive Code\n\n**Dependencies:**\n- Blocks: All phases complete\n\n**Success Criteria:**\n- Complete API docs\n- Interactive examples\n- TypeScript docs\n- Search works\n- Mobile friendly","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-09T16:48:38.008872+01:00","updated_at":"2025-11-09T16:49:28.774733+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-u6q","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:49:28.813032+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-uas","content_hash":"071f10e00221a9d7b416950e4bfd228f0d596c5647b950c052175b5a3e5467a9","title":"Phase 2, Task 1: Create declarative Canvas render tree abstraction","description":"**Goal:** Create a virtual DOM-like abstraction for Canvas rendering that separates render description from execution.\n\n**Implementation:**\n\n1. Create `src/renderer/RenderTree.ts`:\n```typescript\nexport type RenderNode = {\n  type: 'path' | 'rect' | 'line' | 'text' | 'group'\n  props: RenderProps\n  children?: RenderNode[]\n  key?: string\n}\n\nexport type RenderProps = {\n  // Common\n  opacity?: number\n  transform?: { x: number; y: number; scale?: number }\n  \n  // Path specific\n  d?: string\n  fill?: string\n  stroke?: string\n  lineWidth?: number\n  \n  // Text specific\n  text?: string\n  font?: string\n  \n  // Rect specific\n  x?: number\n  y?: number\n  width?: number\n  height?: number\n}\n\nexport class RenderTree {\n  constructor(private root: RenderNode) {}\n  \n  // Diff and patch for efficient updates\n  diff(newTree: RenderTree): RenderPatch[]\n  \n  // Convert to canvas operations\n  toCanvasOps(): CanvasOp[]\n}\n```\n\n2. Create `src/renderer/CanvasRenderer.ts`:\n```typescript\nexport class CanvasRenderer {\n  private prevTree: RenderTree | null = null\n  \n  render(tree: RenderTree, ctx: CanvasRenderingContext2D) {\n    if (this.prevTree) {\n      const patches = this.prevTree.diff(tree)\n      this.applyPatches(patches, ctx)\n    } else {\n      this.renderFull(tree, ctx)\n    }\n    this.prevTree = tree\n  }\n  \n  private renderNode(node: RenderNode, ctx: CanvasRenderingContext2D) {\n    ctx.save()\n    this.applyProps(node.props, ctx)\n    \n    switch (node.type) {\n      case 'path':\n        this.renderPath(node, ctx)\n        break\n      case 'rect':\n        this.renderRect(node, ctx)\n        break\n      // ... other types\n    }\n    \n    node.children?.forEach(child =\u003e this.renderNode(child, ctx))\n    ctx.restore()\n  }\n}\n```\n\n**Dependencies:**\n- Blocks: None (can start immediately after Phase 1)\n\n**Success Criteria:**\n- RenderTree can represent all current canvas operations\n- Diffing algorithm correctly identifies changes\n- Performance overhead \u003c 5% compared to direct canvas calls\n- Unit tests for diff/patch logic","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:39:23.168392+01:00","updated_at":"2025-11-09T17:55:16.326681+01:00","closed_at":"2025-11-09T17:55:16.326681+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-uas","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:39:38.588344+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-v9l","content_hash":"c7ad25e1726dc99d3ef21d362ff282dedf0669bdff485046ea2362214f5bc85a","title":"Create performance regression tests","description":"Create automated performance regression tests that fail if \u003e5% slower.\n\n## Performance Test Suite\nFile: scripts/performance-tests.js\n\n### Tests\n```javascript\nconst tests = [\n  {\n    name: 'Initialize WaveSurfer',\n    run: () =\u003e {\n      const start = performance.now()\n      const ws = WaveSurfer.create({ container: '#wave' })\n      const end = performance.now()\n      return end - start\n    },\n    baseline: 50, // ms\n    threshold: 1.05 // 5% slower allowed\n  },\n  {\n    name: 'Load and render',\n    run: async () =\u003e {\n      const ws = WaveSurfer.create({ container: '#wave' })\n      const start = performance.now()\n      await ws.load('/test-audio.mp3')\n      const end = performance.now()\n      return end - start\n    },\n    baseline: 200,\n    threshold: 1.05\n  },\n  {\n    name: 'Playback FPS',\n    run: async () =\u003e {\n      const ws = WaveSurfer.create({ container: '#wave' })\n      await ws.load('/test-audio.mp3')\n      \n      let frames = 0\n      const start = performance.now()\n      \n      ws.on('timeupdate', () =\u003e frames++)\n      ws.play()\n      \n      await new Promise(r =\u003e setTimeout(r, 1000))\n      ws.pause()\n      \n      const end = performance.now()\n      return (frames / ((end - start) / 1000))\n    },\n    baseline: 60, // fps\n    threshold: 0.92 // allow 8% drop (55fps min)\n  }\n]\n```\n\n## CI Integration\nRun in GitHub Actions, fail PR if tests don't pass\n\n## Reports\n- Generate HTML report\n- Post summary to PR\n- Track trends over time","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:29:16.096528+01:00","updated_at":"2025-11-09T14:40:56.921206+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-v9l","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T14:29:16.134902+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-v9l","depends_on_id":"wavesurfer.js-93k","type":"blocks","created_at":"2025-11-09T14:29:16.172736+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-wpg","content_hash":"1f1c31828bdbf44592a862f9521b3b8efc3c1dc71f85af3c86f8ab440343fb64","title":"Epic: Refactor to Declarative/Reactive Architecture","description":"Transform wavesurfer.js from imperative, event-driven architecture to declarative, reactive architecture.\n\n## Goals\n- 20% reduction in LOC (~8,741 → ~7,000)\n- \u003e90% test coverage\n- ≤5% performance overhead\n- Zero memory leaks (automatic cleanup)\n- Better state predictability\n\n## Current Problems\n1. Scattered state across multiple classes\n2. Manual subscription management (memory leak prone)\n3. Imperative DOM updates\n4. Side-effect heavy initialization\n5. Complex event chains hard to debug\n\n## Proposed Solution\n1. Centralized reactive state (signals)\n2. Automatic subscriptions with cleanup\n3. Declarative rendering (state → UI)\n4. Pure functions separated from side effects\n5. Functional Core, Imperative Shell pattern\n\n## Architecture Changes\n- Add src/reactive/ for signal implementation\n- Add src/state/ for centralized state\n- Add src/core/ for pure functions\n- Refactor src/renderer/ to declarative\n- Transform src/player.ts to reactive\n\n## Timeline\n15-21 weeks (4-5 months) across 5 phases\n\n## Migration Strategy\n- Phase-by-phase implementation\n- Feature flags for new renderer\n- Maintain backward compatibility\n- Parallel old/new implementations initially\n- Gradual deprecation over 2+ major versions","status":"open","priority":1,"issue_type":"epic","created_at":"2025-11-09T14:22:16.24749+01:00","updated_at":"2025-11-09T14:33:13.41479+01:00","source_repo":"."}
{"id":"wavesurfer.js-xux","content_hash":"be81db81d9538469596aa50fa46da9d8e0b1e2610343f09360945170601fbde3","title":"Phase 5, Task 4: Update all plugins to reactive architecture","description":"**Goal:** Migrate all plugins to reactive architecture.\n\n**Plugins to Update:**\n- Regions (already converted to reactive DOM rendering in Phase 2, Task 5)\n- Spectrogram (started in Phase 2, Task 10)\n- Timeline\n- Minimap\n- Envelope\n- Record\n- Hover\n- Zoom\n\n**Note:** There is no separate Markers plugin. Markers are simply zero-width regions (where end = start or no end specified) handled by the Regions plugin.\n\n**Migration Pattern:**\n```typescript\nclass Plugin {\n  private subscriptions: (() =\u003e void)[] = []\n  \n  init(wavesurfer: WaveSurfer) {\n    // Subscribe to reactive state\n    this.subscriptions.push(\n      wavesurfer.timeSignal.subscribe(this.onTimeChange.bind(this))\n    )\n    this.subscriptions.push(\n      wavesurfer.zoomSignal.subscribe(this.onZoomChange.bind(this))\n    )\n  }\n  \n  destroy() {\n    this.subscriptions.forEach(unsub =\u003e unsub())\n  }\n}\n```\n\n**Rendering Guidelines:**\n- **Canvas rendering:** Only waveform and spectrogram\n- **DOM rendering:** Everything else (regions, cursor, timeline, hover, markers, etc.)\n- Use signals for state\n- Use effects for reactive updates\n- Ensure proper cleanup\n\n**Plugin-Specific Notes:**\n\n**Timeline:**\n- Uses DOM elements for tick marks and labels\n- Should use signals for visible time range\n- Reactive updates when zoom/scroll changes\n\n**Minimap:**\n- May use small canvas for minimap waveform\n- Should use signals for viewport position\n- Reactive updates for scroll position indicator\n\n**Envelope:**\n- Uses DOM elements for control points\n- Should use signals for envelope data\n- Reactive updates for point positions\n\n**Record:**\n- Uses DOM elements for recording UI\n- Should use signals for recording state\n- Reactive updates for level meters\n\n**Hover:**\n- Uses DOM elements for hover display (already partially reactive - see Task 7)\n- Should use signals for hover position\n- Reactive updates for displayed time/value\n\n**Zoom:**\n- Uses DOM elements for zoom slider\n- Should use signals for zoom level\n- Reactive updates for slider position\n\n**Dependencies:**\n- Blocks: Phase 2 rendering tasks\n\n**Success Criteria:**\n- All plugins reactive\n- No imperative state updates\n- Proper cleanup\n- Tests pass\n- Follows rendering guidelines (canvas vs DOM)","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T16:48:37.903566+01:00","updated_at":"2025-11-09T19:57:17.341032+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-xux","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:49:05.549319+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-xux","depends_on_id":"wavesurfer.js-ed4","type":"blocks","created_at":"2025-11-09T16:49:05.587212+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-xux","depends_on_id":"wavesurfer.js-mec","type":"blocks","created_at":"2025-11-09T16:49:05.626161+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-xux","depends_on_id":"wavesurfer.js-deh","type":"blocks","created_at":"2025-11-09T16:49:05.665481+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-xwg","content_hash":"c2ed4ac5ca0166d9322ebd4b38909ebece2e18c52cb06b9817ca6232f4e64124","title":"Phase 3, Task 4: Convert scroll/zoom events to streams","description":"**Goal:** Handle scroll and zoom with reactive event streams.\n\n**Implementation:**\n```typescript\n// Scroll stream\nprivate setupScrollStream() {\n  const scrolls = fromDOMEvent(this.wrapper, 'scroll')\n    .throttle(16)\n    .map(() =\u003e ({\n      scrollLeft: this.wrapper.scrollLeft,\n      scrollTop: this.wrapper.scrollTop\n    }))\n  \n  scrolls.subscribe(({ scrollLeft }) =\u003e {\n    this.scrollOffsetSignal.value = scrollLeft\n  })\n}\n\n// Wheel zoom stream\nprivate setupWheelZoomStream() {\n  const wheels = fromDOMEvent(this.wrapper, 'wheel')\n    .filter(e =\u003e e.ctrlKey) // Only zoom with Ctrl+wheel\n    .map(e =\u003e {\n      e.preventDefault()\n      return {\n        delta: -e.deltaY,\n        x: e.offsetX,\n        y: e.offsetY\n      }\n    })\n  \n  wheels.subscribe(({ delta, x }) =\u003e {\n    const zoomFactor = delta \u003e 0 ? 1.1 : 0.9\n    const centerTime = this.pixelToTime(x)\n    this.zoomSignal.value *= zoomFactor\n    // Keep center time at same pixel position\n    this.centerOnTime(centerTime, x)\n  })\n}\n\n// Pinch zoom for touch\nprivate setupPinchZoomStream() {\n  // Complex gesture detection as stream\n  const touches = fromDOMEvent(this.canvas, 'touchmove')\n  const pinches = touches\n    .map(detectPinchGesture)\n    .filter(g =\u003e g.type === 'pinch')\n  \n  pinches.subscribe(({ scale, centerX }) =\u003e {\n    this.zoomSignal.value *= scale\n    this.centerOnPixel(centerX)\n  })\n}\n```\n\n**Dependencies:**\n- Blocks: wavesurfer.js-ix6\n\n**Success Criteria:**\n- Scroll works smoothly\n- Wheel zoom works with Ctrl\n- Pinch zoom on touch devices\n- No jank during zoom","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T16:44:53.099757+01:00","updated_at":"2025-11-09T21:32:39.282058+01:00","closed_at":"2025-11-09T21:32:39.282058+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-xwg","depends_on_id":"wavesurfer.js-wpg","type":"parent-child","created_at":"2025-11-09T16:45:57.518172+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-xwg","depends_on_id":"wavesurfer.js-ix6","type":"blocks","created_at":"2025-11-09T16:45:57.556198+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-zg6","content_hash":"3719c10939895d60256005c091236248a2ad5e3eaada1d3559f64cdb4cc82484","title":"Achieve \u003e90% test coverage","description":"Achieve \u003e90% test coverage for entire codebase.\n\n## Coverage Targets\n- Reactive primitives: \u003e95%\n- State management: \u003e90%\n- WaveSurfer core: \u003e90%\n- Renderer: \u003e85%\n- Plugins: \u003e80%\n- Overall: \u003e90%\n\n## Test Types Needed\n- Unit tests for pure functions\n- Integration tests for components\n- E2E tests for user flows\n- Visual regression tests\n- Performance tests\n- Memory leak tests\n\n## Run Coverage\n```bash\nyarn test:unit --coverage\nyarn test:e2e\n```\n\n## Report Generation\n- HTML coverage report\n- Badge for README\n- Track coverage in CI","status":"open","priority":1,"issue_type":"task","created_at":"2025-11-09T14:28:59.110278+01:00","updated_at":"2025-11-09T14:39:14.317535+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-zg6","depends_on_id":"wavesurfer.js-0ib","type":"parent-child","created_at":"2025-11-09T14:28:59.149103+01:00","created_by":"daemon"}]}
{"id":"wavesurfer.js-zgh","content_hash":"e7a02b08c76989894a902a63a0bcc5bce50f522daac44902986760ebe3d2d1eb","title":"Migrate progress rendering to reactive pattern","description":"Migrate progress bar rendering to use reactive effects.\n\n## Current Implementation (Imperative)\n```typescript\n// Called manually from timer tick\nprivate updateProgress(currentTime = this.getCurrentTime()): number {\n  this.renderer.renderProgress(currentTime / this.getDuration(), this.isPlaying())\n  return currentTime\n}\n```\n\n## New Implementation (Reactive)\n```typescript\n// Automatic - no manual calls needed\neffect(\n  () =\u003e {\n    const progress = state.progressPercent.value\n    this.updateProgressUI(progress)\n  },\n  [state.progressPercent]\n)\n\n// Auto-scroll when playing\neffect(\n  () =\u003e {\n    if (state.isPlaying.value \u0026\u0026 options.autoScroll) {\n      this.autoScroll(state.progressPercent.value)\n    }\n  },\n  [state.isPlaying, state.progressPercent]\n)\n```\n\n## updateProgressUI(progress: number)\nPure function that updates DOM:\n```typescript\nprivate updateProgressUI(progress: number) {\n  const positionX = progress * this.wrapper.scrollWidth\n  this.progressWrapper.style.width = `${positionX}px`\n  \n  if (this.options.cursorWidth) {\n    this.cursor.style.left = `${positionX - this.options.cursorWidth / 2}px`\n    this.cursor.style.width = `${this.options.cursorWidth}px`\n  }\n}\n```\n\n## Benefits\n- No timer polling needed\n- Updates only when time actually changes\n- Automatic batching of multiple updates\n- Easier to test (pure function)\n- Clear data flow: time → percent → UI\n\n## Testing\n- Test progress bar width updates\n- Test cursor position updates\n- Test auto-scroll triggers when playing\n- Test no updates when paused\n- Test multiple rapid updates batch correctly\n- Test visual correctness\n\n## Integration\n- Keep old implementation for now\n- New implementation behind feature flag\n- Both should produce identical visuals\n- Performance should be comparable or better","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-09T14:23:44.949354+01:00","updated_at":"2025-11-09T16:19:05.880571+01:00","closed_at":"2025-11-09T16:19:05.880571+01:00","source_repo":".","dependencies":[{"issue_id":"wavesurfer.js-zgh","depends_on_id":"wavesurfer.js-gmg","type":"parent-child","created_at":"2025-11-09T14:23:44.987922+01:00","created_by":"daemon"},{"issue_id":"wavesurfer.js-zgh","depends_on_id":"wavesurfer.js-725","type":"blocks","created_at":"2025-11-09T14:23:45.025387+01:00","created_by":"daemon"}]}
