---
layout: default
---
<section>
  <h1>FAQ</h1>

  <h2>Can the audio start playing before the waveform is drawn?</h2>

  <p>Yes, if you use the <code>backend: 'MediaElement'</code> option. See here: <a href="https://wavesurfer-js.org/example/audio-element/">http://wavesurfer-js.org/example/audio-element/</a>. The audio will start playing as you press play. A thin line will be displayed until the whole audio file is downloaded and decoded to draw the waveform.</p>

  <h2>Can drawing be done as file loads?</h2>

  <p>No. Web Audio needs the whole file to decode it in the browser. You can however load pre-decoded waveform data to draw the waveform immediately. <a href="/example/audio-element/">See here</a> (the "Pre-recoded Peaks" section).</p>

  <h2>Can I make the audio start playing automatically on iOS?</h2>

  <p>Nope. It's a known issue that iOS won't allow you to play the audio programmatically. It won't play unless the user clicks on the page. It's a power/bandwidth-saving feature of iOS Safari.</p>

  <h2>How to generate waveform data on the server?</h2>

  <p>
    You can use the <a href="https://github.com/bbc/audiowaveform">audiowaveform</a> program. For example, let's generate peaks for a MP3 file called 'long_clip.mp3'.
  <p>Generate JSON-formatted peaks data from the file <code>long_clip.mp3</code>:</p>
  <pre><code>audiowaveform -i long_clip.mp3 -o long_clip.json --pixels-per-second 20 --bits 8</code></pre>
  <p>To generate waveforms for each audio channel separately, add the '--split-channels' flag <code>long_clip.mp3</code>:</p>
  <pre><code>audiowaveform -i long_clip.mp3 -o long_clip.json --pixels-per-second 20 --bits 8 --split-channels</code></pre>
  <h3>Normalization</h3>
  <p>audiowaveform will create non-normalized peak data. Wavesurfer.js expects peak data between 0 and 1. There are two ways to normalize:</p>
  <h4>Client-side</h4>
  <p>The easiest way to normalize the peak data is by enabling `normalize: true` in the WaveSurfer settings. The peak data will be transformed client-side.<p>
  <pre><code>
var wavesurfer = WaveSurfer.create({
  container: '#waveform',
  waveColor: 'violet',
  progressColor: 'purple'
  normalize: true,
});
</code></pre>
  <h4>Server-side</h4>
  <p>You can also pre-normalize the peak data instead of letting the client do it on every load. This could improve performance somewhat, which might be important for large audio files.<p>
  <p>You can do this normalization with the following Python script:</p>
  <pre><code>python scale-json.py long_clip.json</code></pre>
  <pre><code>
import sys
import json


def scale_json(filename):
    with open(filename, "r") as f:
        file_content = f.read()

    json_content = json.loads(file_content)
    data = json_content["data"]
    channels = json_content["channels"]
    # number of decimals to use when rounding the peak value
    digits = 2

    max_val = float(max(data))
    new_data = []
    for x in data:
        new_data.append(round(x / max_val, digits))
    # audiowaveform is generating interleaved peak data when using the --split-channels flag, so we have to deinterleave it
    if channels > 1:
        deinterleaved_data = deinterleave(new_data, channels)
        json_content["data"] = deinterleaved_data
    else:
        json_content["data"] = new_data
    file_content = json.dumps(json_content, separators=(',', ':'))

    with open(filename, "w") as f:
        f.write(file_content)


def deinterleave(data, channelCount):
    # first step is to separate the values for each audio channel and min/max value pair, hence we get an array with channelCount * 2 arrays
    deinterleaved = [data[idx::channelCount * 2] for idx in range(channelCount * 2)]
    new_data = []

    # this second step combines each min and max value again in one array so we have one array for each channel
    for ch in range(channelCount):
        idx1 = 2 * ch
        idx2 = 2 * ch + 1
        ch_data = [None] * (len(deinterleaved[idx1]) + len(deinterleaved[idx2]))
        ch_data[::2] = deinterleaved[idx1]
        ch_data[1::2] = deinterleaved[idx2]
        new_data.append(ch_data)
    return new_data


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python scale_json.py file.json")
        exit()
    filename = sys.argv[1]
    scale_json(filename)

</code></pre>
<h3>Loading the peak data</h3>
<p>You can now load the <code>long_clip.json</code> file with the peaks data and pass it to wavesurfer.js:</p>
<pre><code>
fetch('../long_clip.json')
.then(response => {
    if (!response.ok) {
        throw new Error("HTTP error " + response.status);
    }
    return response.json();
})
.then(peaks => {
    console.log('loaded peaks! sample_rate: ' + peaks.sample_rate);

    // load peaks into wavesurfer.js
    wavesurfer.load(mediaElt, peaks.data);
})
.catch((e) => {
    console.error('error', e);
});
</code></pre>
  </p>
</section>
